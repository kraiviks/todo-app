{"version":3,"sources":["entities/task/ui/task-card/index.tsx","entities/task/ui/task-row/index.tsx","shared/api/typicode/base.ts","shared/api/typicode/tasks.ts","entities/task/model/tasks.ts","entities/task/lib.ts","entities/task/ui/task-card/styles.module.scss","entities/task/ui/task-row/styles.module.scss","features/toggle-task/model/toggle-task.ts","features/toggle-task/ui.tsx","pages/tasks-list/styles.module.scss","features/tasks-filters/config.ts","features/tasks-filters/ui.tsx","pages/tasks-list/index.tsx"],"names":["TaskCard","_ref","data","titleHref","children","cardProps","loading","_jsxs","Card","title","concat","id","className","styles","root","_jsx","Link","to","TaskRow","before","Row","cn","completed","apiInstance","axios","create","baseURL","API_URL","BASE_URL","getTasksList","params","get","getTaskById","taskId","setQueryConfig","createEvent","getTasksListFx","createEffect","typicodeApi","tasks","getTaskByIdFx","taskSchema","schema","Entity","normalizeTask","normalize","normalizeTasks","tasksInitialState","$tasks","createStore","on","doneData","_","payload","entities","state","$queryConfig","$tasksListLoading","pending","$taskDetailsLoading","$tasksList","combine","Object","values","$tasksFiltered","tasksList","config","filter","task","undefined","$tasksListEmpty","map","list","length","events","effects","selectors","useTask","useStore","getTaskStatus","module","exports","toggleTask","taskModel","produce","draft","ToggleTask","withStatus","status","taskLib","Checkbox","onClick","toggleTaskModel","checked","filters","filtersList","TasksFilters","reflect","view","onFilterClick","Radio","Group","defaultValue","buttonStyle","_ref2","Button","getFilterById","value","disabled","bind","TasksListPage","Layout","toolbar","justify","Typography","Title","level","Content","content","gutter","PageContent","TasksList","Col","span","source","mapItem","variant","isLoading","isEmpty","cases","Spin","size","empty","Empty","description","ready","hooks","mounted","prepend"],"mappings":"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","file":"static/js/5.c11f7069.chunk.js","sourcesContent":["import type { PropsWithChildren, ReactElement } from \"react\";\nimport { Link } from \"react-router-dom\";\n\nimport { typicodeApi } from \"shared/api\";\nimport { Card } from \"shared/ui\";\n\nimport styles from \"./styles.module.scss\";\n\nexport type TaskCardProps = PropsWithChildren<{\n  data?: typicodeApi.models.Task;\n  titleHref?: string;\n}> &\n  import(\"antd\").CardProps;\n\nexport const TaskCard = ({\n  data,\n  titleHref,\n  children,\n  ...cardProps\n}: TaskCardProps): ReactElement | null => {\n  if (!data && !cardProps.loading) return null;\n\n  return (\n    <Card\n      title={`Task#${cardProps.loading ? \"\" : data?.id}`}\n      className={styles.root}\n      {...cardProps}\n    >\n      {titleHref ? <Link to={titleHref}>{data?.title}</Link> : data?.title}\n      {children}\n    </Card>\n  );\n};\n","import cn from \"classnames\";\nimport type { PropsWithChildren, ReactElement, ReactNode } from \"react\";\nimport { Link } from \"react-router-dom\";\n\nimport { typicodeApi } from \"shared/api\";\nimport { Row } from \"shared/ui\";\n\nimport styles from \"./styles.module.scss\";\n\nexport type TaskRowProps = PropsWithChildren<{\n  data: typicodeApi.models.Task;\n  titleHref?: string;\n  before?: ReactNode;\n}>;\n\nexport const TaskRow = ({\n  data,\n  before,\n  titleHref,\n}: TaskRowProps): ReactElement => {\n  const title = titleHref ? (\n    <Link to={titleHref}>{data.title}</Link>\n  ) : (\n    data.title\n  );\n\n  return (\n    <Row className={cn(styles.root, { [styles.completed]: data.completed })}>\n      {before}\n      {title}\n    </Row>\n  );\n};\n","import axios from \"axios\";\n\nimport { API_URL } from \"shared/config\";\n\n// Potentially, you could pass an accessToken\nexport const apiInstance = axios.create({\n  baseURL: API_URL,\n});\n","import type { AxiosPromise } from \"axios\";\n\nimport { apiInstance } from \"./base\";\nimport type { Task } from \"./models\";\n\nconst BASE_URL = \"/todos\";\n\nexport interface GetTasksListParams {\n  userId?: number;\n  completed?: boolean;\n}\n\nexport const getTasksList = (\n  params?: GetTasksListParams\n): AxiosPromise<Task[]> => apiInstance.get(BASE_URL, { params });\n\nexport interface GetTaskByIdParams {\n  taskId: number;\n  [x: string]: unknown;\n}\n\nexport const getTaskById = ({\n  taskId,\n  ...params\n}: GetTaskByIdParams): AxiosPromise<Task> =>\n  apiInstance.get(`${BASE_URL}/${taskId}`, { params });\n","import { createStore, combine, createEffect, createEvent } from \"effector\";\nimport { useStore } from \"effector-react\";\nimport { normalize, schema, NormalizedSchema } from \"normalizr\";\n\nimport { typicodeApi } from \"shared/api\";\n\nexport interface QueryConfig {\n  completed?: boolean;\n  userId?: number;\n}\n\nconst setQueryConfig = createEvent<QueryConfig>();\n\n// Each effect can also have its own additional processing\nconst getTasksListFx = createEffect(\n  (params?: typicodeApi.tasks.GetTasksListParams) =>\n    typicodeApi.tasks.getTasksList(params)\n);\nconst getTaskByIdFx = createEffect(\n  (params: typicodeApi.tasks.GetTaskByIdParams) =>\n    typicodeApi.tasks.getTaskById(params)\n);\n\n// It is possible to bring normalization to the API level\ntype NormalizedTaskSchema<R> = NormalizedSchema<\n  { tasks: Record<number, typicodeApi.models.Task> },\n  R\n>;\nexport const taskSchema = new schema.Entity(\"tasks\");\nexport const normalizeTask = (\n  data: typicodeApi.models.Task\n): NormalizedTaskSchema<number> => normalize(data, taskSchema);\nexport const normalizeTasks = (\n  data: typicodeApi.models.Task[]\n): NormalizedTaskSchema<number[]> => normalize(data, [taskSchema]);\n\n// It is not critical within the demo, but you can also store it as an array without normalization\nexport const tasksInitialState: Record<number, typicodeApi.models.Task> = {};\nexport const $tasks = createStore(tasksInitialState)\n  .on(\n    getTasksListFx.doneData,\n    (_, payload) => normalizeTasks(payload.data).entities.tasks\n  )\n  .on(getTaskByIdFx.doneData, (state, payload) => ({\n    ...state,\n    ...normalizeTask(payload.data).entities.tasks,\n  }));\n\n// You can put it in a separate directory (for storing multiple models)\nexport const $queryConfig = createStore<QueryConfig>({}).on(\n  setQueryConfig,\n  (_, payload) => payload\n);\n\n// You can add potentially debounceable logic\nexport const $tasksListLoading = getTasksListFx.pending;\nexport const $taskDetailsLoading = getTaskByIdFx.pending;\n\n/**\n * \"List\" of tasks\n */\nexport const $tasksList = combine($tasks, (tasks) => Object.values(tasks));\n\n/**\n * Filtered tasks\n * @remark It is possible to handle it at the effect level - but then you need to plug additional logic into the store\n * > For example, hide/show task at `toggleTask` event\n */\nexport const $tasksFiltered = combine(\n  $tasksList,\n  $queryConfig,\n  (tasksList, config) =>\n    tasksList.filter(\n      (task) =>\n        config.completed === undefined || task.completed === config.completed\n    )\n);\n\nexport const $tasksListEmpty = $tasksFiltered.map((list) => list.length === 0);\n\n// If desired, you can have a separate selector that is not tied to react bindings\nconst useTask = (taskId: number): typicodeApi.models.Task | undefined =>\n  useStore($tasks)[taskId];\n\nexport const events = { setQueryConfig };\n\nexport const effects = {\n  getTaskByIdFx,\n  getTasksListFx,\n};\n\nexport const selectors = {\n  useTask,\n};\n","import { typicodeApi } from \"shared/api\";\n\ntype TaskStatus = \"CLOSED\" | \"OPENED\";\n\nexport const getTaskStatus = (data: typicodeApi.models.Task): TaskStatus =>\n  data.completed ? \"CLOSED\" : \"OPENED\";\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__1Slir\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__fGMdR\",\"completed\":\"styles_completed__2aSOy\"};","import { createEvent } from \"effector\";\nimport produce from \"immer\";\n\nimport { taskModel } from \"entities/task\";\n\nconst toggleTask = createEvent<number>();\n\ntaskModel.$tasks.on(toggleTask, (state, taskId) =>\n  produce(state, (draft) => {\n    const task = draft[taskId];\n    task.completed = !task.completed;\n  })\n);\n\nexport const events = { toggleTask };\n","import { ReactElement } from \"react\";\n\nimport { Checkbox } from \"shared/ui\";\n\nimport { taskModel, taskLib } from \"entities/task\";\n\nimport * as toggleTaskModel from \"./model\";\n\nexport type ToggleTaskProps = {\n  taskId: number;\n  withStatus?: boolean;\n};\n\n// resolve / unresolve\nexport const ToggleTask = ({\n  taskId,\n  withStatus = true,\n}: ToggleTaskProps): ReactElement | null => {\n  const task = taskModel.selectors.useTask(taskId);\n\n  if (!task) return null;\n\n  const status = taskLib.getTaskStatus(task);\n\n  return (\n    <Checkbox\n      onClick={() => toggleTaskModel.events.toggleTask(taskId)}\n      checked={task.completed}\n    >\n      {withStatus && status}\n    </Checkbox>\n  );\n};\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"root\":\"styles_root__3vhW2\",\"toolbar\":\"styles_toolbar__2OJM3\",\"content\":\"styles_content__1K7j8\"};","export interface Filter {\n  id: number;\n  title: string;\n  config: import(\"entities/task\").taskModel.QueryConfig;\n}\n\n// We describe here the dataset of \"Closed\" / \"Open\" filters, etc.\nexport const filters: Record<number, Filter> = {\n  1: {\n    id: 1,\n    title: \"All\",\n    config: {},\n  },\n  2: {\n    id: 2,\n    title: \"Opened\",\n    config: { completed: false },\n  },\n  3: {\n    id: 3,\n    title: \"Closed\",\n    config: { completed: true },\n  },\n};\n\nexport const DEFAULT_FILTER = 1;\n\nexport const filtersList = Object.values(filters);\n\nexport const getFilterById = (id: number): Filter => filters[id];\n","import { reflect } from \"@effector/reflect\";\n\nimport { Radio } from \"shared/ui\";\n\nimport { taskModel } from \"entities/task\";\n\nimport { filtersList, getFilterById, DEFAULT_FILTER } from \"./config\";\n\ntype Props = {\n  loading: boolean;\n  onFilterClick: (p: taskModel.QueryConfig) => void;\n};\n\nconst View = ({ loading, onFilterClick }: Props) => {\n  return (\n    <Radio.Group defaultValue={DEFAULT_FILTER} buttonStyle=\"solid\">\n      {filtersList.map(({ title, id }) => (\n        <Radio.Button\n          key={id}\n          onClick={() => onFilterClick(getFilterById(id).config)}\n          value={id}\n          disabled={loading}\n        >\n          {title}\n        </Radio.Button>\n      ))}\n    </Radio.Group>\n  );\n};\n\n// The use of effector-reflect here is optional and not critical within the methodology\nexport const TasksFilters = reflect({\n  view: View,\n  bind: {\n    loading: taskModel.$tasksListLoading,\n    onFilterClick: taskModel.events.setQueryConfig,\n  },\n});\n","import { variant, list } from \"@effector/reflect\";\nimport { combine } from \"effector\";\nimport { ReactElement } from \"react\";\n\nimport { typicodeApi } from \"shared/api\";\nimport { Layout, Row, Col, Typography, Spin, Empty } from \"shared/ui\";\n\nimport { TaskRow, taskModel } from \"entities/task\";\n\nimport { TasksFilters } from \"features/tasks-filters\";\nimport { ToggleTask } from \"features/toggle-task\";\n\nimport styles from \"./styles.module.scss\";\n\nexport const TasksListPage = (): ReactElement => {\n  return (\n    <Layout className={styles.root}>\n      <Layout className={styles.toolbar}>\n        {/* ~ Layout.Toolbar */}\n        <Row justify=\"center\">\n          <Typography.Title level={1}>Tasks List</Typography.Title>\n        </Row>\n        <Row justify=\"center\">\n          <TasksFilters />\n        </Row>\n      </Layout>\n      <Layout.Content className={styles.content}>\n        <Row gutter={[0, 20]} justify=\"center\">\n          {/* eslint-disable-next-line no-use-before-define */}\n          <PageContent />\n        </Row>\n      </Layout.Content>\n    </Layout>\n  );\n};\n\nconst ListItemView: React.FC<{ task: typicodeApi.models.Task }> = ({\n  task,\n}) => {\n  return (\n    <Col key={task.id} span={24}>\n      <TaskRow\n        data={task}\n        titleHref={`/${task.id}`}\n        before={<ToggleTask taskId={task.id} withStatus={false} />}\n      />\n    </Col>\n  );\n};\n\n// The use of effector-reflect here is optional and not critical within the methodology\nconst TasksList = list({\n  view: ListItemView,\n  source: taskModel.$tasksFiltered,\n  bind: {},\n  mapItem: {\n    task: (task) => task,\n  },\n});\n\n// The use of effector-reflect here is optional and not critical within the methodology\nconst PageContent = variant({\n  source: combine(\n    {\n      isLoading: taskModel.$tasksListLoading,\n      isEmpty: taskModel.$tasksListEmpty,\n    },\n    ({ isLoading, isEmpty }) => {\n      if (isLoading) return \"loading\";\n      if (isEmpty) return \"empty\";\n      return \"ready\";\n    }\n  ),\n  cases: {\n    loading: () => <Spin size=\"large\" />,\n    empty: () => <Empty description=\"No tasks found\" />,\n    ready: TasksList,\n  },\n  hooks: {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    mounted: taskModel.effects.getTasksListFx.prepend(() => {}),\n  },\n});\n"],"sourceRoot":""}