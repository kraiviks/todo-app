{"version":3,"sources":["../node_modules/axios/lib/utils.js","../effector/is.ts","../effector/region.ts","../effector/createNode.ts","../effector/tag.ts","../effector/kernel.ts","../effector/naming.ts","../effector/collection.ts","../effector/createUnit.ts","../effector/combine.ts","../effector/defer.ts","../effector/createEffect.ts","../effector/attach.ts","../effector/createApi.ts","../effector/createDomain.ts","../effector/fromObservable.ts","../effector/merge.ts","../effector/sample.ts","../effector/guard.ts","../effector/restore.ts","../effector/split.ts","../effector/fork.ts","../effector/observable.ts","../effector/validate.ts","../effector/throw.ts","../effector/id.ts","../effector/bind.ts","../effector/step.ts","../effector/stateRef.ts","../effector/caller.ts","../effector/getter.ts","../effector/own.ts","../effector/config.ts","../effector/clearNode.ts","../effector/subscription.ts","../effector/forward.ts","../effector/watch.ts","../node_modules/@effector/reflect/no-ssr/index.js","../effector-react/useStore.ts","../effector-react/withDisplayName.ts","../effector-react/createComponent.ts","../effector-react/createStoreConsumer.ts","../effector-react/useList.ts","../effector-react/createReactState.ts","../effector-react/createGate.ts","../effector-react/nossr.ts","../effector-react/useIsomorphicLayoutEffect.ts","../effector-react/throw.ts","../effector-react/createContextComponent.ts","../effector-react/connect.ts","../node_modules/axios/lib/defaults.js","../node_modules/axios/index.js","../node_modules/axios/lib/helpers/bind.js","../node_modules/axios/lib/helpers/buildURL.js","../node_modules/axios/lib/core/enhanceError.js","../node_modules/axios/lib/adapters/xhr.js","../node_modules/axios/lib/core/createError.js","../node_modules/axios/lib/cancel/isCancel.js","../node_modules/axios/lib/core/mergeConfig.js","../node_modules/axios/lib/cancel/Cancel.js","../node_modules/normalizr/dist/normalizr.es.js","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/types/types-internal.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/immer.ts","../../src/utils/env.ts","../node_modules/@effector/reflect/dist/no-ssr/index.js","../node_modules/@effector/reflect/dist/list-98ebb739.js","../node_modules/axios/lib/axios.js","../node_modules/axios/lib/core/Axios.js","../node_modules/axios/lib/core/InterceptorManager.js","../node_modules/axios/lib/core/dispatchRequest.js","../node_modules/axios/lib/core/transformData.js","../node_modules/axios/lib/helpers/normalizeHeaderName.js","../node_modules/axios/lib/core/settle.js","../node_modules/axios/lib/helpers/cookies.js","../node_modules/axios/lib/core/buildFullPath.js","../node_modules/axios/lib/helpers/isAbsoluteURL.js","../node_modules/axios/lib/helpers/combineURLs.js","../node_modules/axios/lib/helpers/parseHeaders.js","../node_modules/axios/lib/helpers/isURLSameOrigin.js","../node_modules/axios/lib/helpers/validator.js","../node_modules/axios/lib/cancel/CancelToken.js","../node_modules/axios/lib/helpers/spread.js","../node_modules/axios/lib/helpers/isAxiosError.js"],"names":["bind","require","toString","Object","prototype","isArray","val","call","isUndefined","isObject","isPlainObject","getPrototypeOf","isFunction","forEach","obj","fn","i","l","length","key","hasOwnProperty","module","exports","isArrayBuffer","isBuffer","constructor","isFormData","FormData","isArrayBufferView","ArrayBuffer","isView","buffer","isString","isNumber","isDate","isFile","isBlob","isStream","pipe","isURLSearchParams","URLSearchParams","isStandardBrowserEnv","navigator","product","window","document","merge","result","assignValue","slice","arguments","extend","a","b","thisArg","trim","str","replace","stripBOM","content","charCodeAt","assertNodeSetItem","value","method","valueName","reason","throwError","assertNodeSet","Array","withRegion","unit","cb","unitMeta","getGraph","meta","regionStack","parent","template","readTemplate","sidRoot","getParent","createNode","node","from","source","to","target","child","scope","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","reg","item","push","addToReg","id","nextNodeID","next","getOwners","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","pushFirstHeapItem","isRoot","stop","skip","lastStartedState","isWatch","kernelLoop","deleteMin","idx","stack","local","fail","stepn","step","data","barrierID","fullID","priority","barriers","has","add","pushHeap","delete","store","STORE","getPageForRef","readRef","getPageRef","current","tryRun","op","unitObjectName","objOrArr","name","comma","is","compositeName","fullName","setStoreName","rawName","createName","shortName","currentComposite","path","composite","concat","forIn","list","createEvent","nameOrConfig","maybeConfig","event","args","oldPage","setCurrentPage","create","graphite","initUnit","find","watch","watchUnit","map","config","mapped","mapName","createComputation","MAP","filter","createEventFiltration","callStack","filterMap","defined","prepend","contramapped","upward","applyParentHook","createStore","defaultState","props","onEvent","off","getSubscribers","set","createSubscription","updateStore","updateFilter","plainState","createStateRef","oldState","updates","createNamedEvent","after","plain","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","nodeMap","reset","units","on","nodeSet","currentSubscription","get","firstState","lastResult","storeState","innerStore","strict","linkNode","getStoreState","before","includes","loader","unshift","eventOrFn","subscription","of","defaultConfig","changed","update","_","isStrict","combine","handler","stores","onConfigNesting","injectedData","userConfig","structStoreShape","shapeReady","rawHandler","spreadArgs","storeCombination","createDefer","req","Promise","rs","rj","catch","err","createEffect","instance","getType","onCopy","kind","use","anyway","finally","done","named","status","error","doneData","failData","effectRunner","getHandler","getCurrent","onResolve","onSettled","ok","onReject","then","fx","runner","upd","savedFork","setForkPage","inFlight","x","pending","amount","attach","injected","effect","mapParams","runnerSteps","attached","runnerFn","computedParams","readStateRef","splice","createApi","setters","metadata","processArgsToConfig","createDomain","domains","Set","effects","events","history","domain","hooks","onCreateEvent","createHook","onCreateEffect","onCreateStore","onCreateDomain","forward","fromObservable","observable","assertObject","observableItem","observableSymbol","subscribe","disposer","bind2","clearNode","undefined","complete","sample","sid","greedy","clock","atLeastOneFieldExists","sampleConfigFields","field","needToCombine","isUpward","targetTemplate","nativeTemplate","sourceRef","createLinkNode","callARegStack","closure","hasSource","sourceState","clockState","callStackAReg","guard","filterIsUnit","restore","É”","v","split","targets","match","knownCases","cases","matchIsUnit","matchIsFunction","matchIsShape","__","splitterSeq","values","caseNames","keys","scopeTargets","String","launchCase","lastValues","needBarrier","updaterSteps","storeOrFn","updater","storeRef","caseName","hydrate","isScope","cloneOf","storeWatches","storeWatchesRefs","normalizedValues","normalizeValues","sidMap","changedStores","forkOf","fillResult","collectWatches","flatGraphUnits","refsMap","predefinedRefs","valuesSidList","getOwnPropertyNames","owner","ref","toposort","createRefGraph","isFresh","cmd","execRef","fillValues","flatGraph","items","refGraph","serialize","clones","ignore","onlyChanges","isCombine","scopeBind","savedForkPage","localUnit","assertEach","fork","handlers","needToFill","forked","findClone","index","indexOf","unitName","refs","putStoreToChanged","forkInFlightCounter","defers","fxID","resolve","parentFork","hasRef","newRef","copyField","origValue","forEachRelatedNode","siblings","wrapped","EFFECT","cloneGraph","sourceList","sourceRefsMap","templateOwnedRefs","handlerKeys","rawGraph","topologicalSortHelper","temp","neighbors","graph","n","visited","reverse","size","processed","ignored","shift","removeItem","allSettled","start","ctx","reject","Error","launchUnits","launchParams","traverse","Symbol","message","idCount","nextUnitID","nextStepID","arg","nextBarrierID","barrier","mov","check","compute","run","getConfig","opts","getNestedConfig","ownerUnit","link","readSidRoot","withFactory","loc","heap","ret","isSameType","r","queue","ix","first","last","getPriority","bucket","t","newForkPage","newPage","console","joinName","tag","rawConfig","pos","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","ownerSet","unsubscribe","forkedNode","normalizeConfig","part","hookType","rawConfigA","rawConfigB","isDomain","unitId","thru","observer","stateFirst","clone","stateNew","rawShape","childRef","defaultShape","sidechain","trigger","acc","res","hook","useStore","currentValue","inc","React","useReducer","currentStore","useRef","useIsomorphicLayoutEffect","newValue","useStoreMap","configOrStore","separateFn","useMemo","withDisplayName","Component","displayName","createComponent","shape","renderProp","RenderComponent","propsRef","mounted","unmounted","storeName","createStoreConsumer","children","useList","renderItem","getKey","Item","keyVal","fnRef","memo","keysSelfMemo","createElement","createReactState","assign","useGate","GateComponent","open","close","aKeys","bKeys","shallowCompare","createGate","useGateHook","Boolean","useEvent","useLayoutEffect","useEffect","createContextComponent","context","useContext","connect","View","utils","normalizeHeaderName","enhanceError","DEFAULT_CONTENT_TYPE","setContentTypeIfUnset","headers","defaults","transitional","silentJSONParsing","forcedJSONParsing","clarifyTimeoutError","adapter","XMLHttpRequest","process","getDefaultAdapter","transformRequest","rawValue","parser","encoder","JSON","parse","e","stringify","stringifySafely","transformResponse","this","strictJSONParsing","responseType","timeout","xsrfCookieName","xsrfHeaderName","maxContentLength","maxBodyLength","validateStatus","common","apply","encode","encodeURIComponent","url","paramsSerializer","serializedParams","parts","toISOString","join","hashmarkIndex","code","request","response","isAxiosError","toJSON","description","number","fileName","lineNumber","columnNumber","settle","cookies","buildURL","buildFullPath","parseHeaders","isURLSameOrigin","createError","requestData","requestHeaders","auth","username","password","unescape","Authorization","btoa","fullPath","baseURL","onloadend","responseHeaders","getAllResponseHeaders","responseText","statusText","toUpperCase","onreadystatechange","readyState","responseURL","setTimeout","onabort","onerror","ontimeout","timeoutErrorMessage","xsrfValue","withCredentials","read","toLowerCase","setRequestHeader","onDownloadProgress","addEventListener","onUploadProgress","upload","cancelToken","promise","cancel","abort","send","__CANCEL__","config1","config2","valueFromConfig2Keys","mergeDeepPropertiesKeys","defaultToConfig2Keys","directMergeKeys","getMergedValue","mergeDeepProperties","prop","axiosKeys","otherKeys","Cancel","_defineProperties","descriptor","enumerable","configurable","writable","defineProperty","_createClass","Constructor","protoProps","staticProps","_extends","_inheritsLoose","subClass","superClass","__proto__","isImmutable","object","_map","denormalizeImmutable","schema","input","unvisit","reduce","stringKey","EntitySchema","definition","options","_options","_options$idAttribute","idAttribute","_options$mergeStrateg","mergeStrategy","entityA","entityB","_options$processStrat","processStrategy","_options$fallbackStra","fallbackStrategy","_key","_getId","getDefaultGetId","_idAttribute","_mergeStrategy","_processStrategy","_fallbackStrategy","define","_proto","entitySchema","_extends2","getId","fallback","normalize","visit","addEntity","visitedEntities","_this","entityType","some","entity","processedEntity","resolvedSchema","denormalize","_this2","PolymorphicSchema","schemaAttribute","_schemaAttribute","getSchemaAttribute","isSingleSchema","inferSchema","attr","normalizeValue","normalizedValue","denormalizeValue","schemaKey","UnionSchema","_PolymorphicSchema","ValuesSchema","output","_extends3","entityOrId","validateSchema","getValues","ArraySchema","_normalize","localSchema","resolvedLocalSchema","_denormalize","ObjectSchema","_len","_len2","_key2","Entity","Union","Values","normalize$1","entities","existingEntity","addEntities","die","msg","s","isDraft","DRAFT_STATE","isDraftable","proto","Ctor","Function","objectCtorString","DRAFTABLE","isMap","isSet","each","iter","enumerableOnly","getArchtype","ownKeys","entry","thing","type_","propOrOldValue","y","hasMap","hasSet","latest","copy_","base_","shallowCopy","base","descriptors","getOwnPropertyDescriptors","desc","freeze","isFrozen","dontMutateFrozenCollections","getPlugin","pluginKey","plugin","plugins","getCurrentScope","currentScope","usePatchesInScope","patchListener","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","drafts_","revokeDraft","parent_","enterScope","immer","immer_","canAutoFreeze_","unfinalizedDrafts_","draft","revoke_","revoked_","processResult","baseDraft","isReplaced","useProxies_","willFinalizeES5_","modified_","finalize","maybeFreeze","generateReplacementPatches_","NOTHING","rootScope","childValue","finalizeProperty","scope_","finalized_","draft_","generatePatches_","parentState","targetObject","rootPath","assigned_","autoFreeze_","peek","getDescriptorFromProto","getOwnPropertyDescriptor","markChanged","prepareCopy","createProxy","proxyMap_","proxySet_","isManual_","traps","objectTraps","arrayTraps","Proxy","revocable","revoke","proxy","createES5Proxy_","currentImpl","copy","archType","hasChanges_","copyHelper","hasSymbol","hasProxies","Reflect","for","iterator","getOwnPropertySymbols","currentState","deleteProperty","setPrototypeOf","Immer","recipe","defaultBase","self","produce","hasError","arg1","arg2","produceWithPatches","p","ip","patches","inversePatches","useProxies","setUseProxies","autoFreeze","setAutoFreeze","createDraft","finishDraft","applyPatches","patch","applyPatchesImpl","applyPatches_","list$1","_interopNamespace","__esModule","k","d","context__namespace","reflect","reflectFactory","createReflect","reflectCreateFactory","variant","variantFactory","listFactory","react","effector","$bind","_a","_b","storeProps","eventsProps","elementProps","hookMounted","readHook","hookUnmounted","view","Default","ItemView","finalProps","mapItem","propValue","nameOfCase","Axios","mergeConfig","createInstance","axios","instanceConfig","CancelToken","isCancel","all","promises","spread","default","InterceptorManager","dispatchRequest","validator","validators","interceptors","assertOptions","boolean","requestInterceptorChain","synchronousRequestInterceptors","interceptor","runWhen","synchronous","fulfilled","rejected","responseInterceptorChain","chain","newConfig","onFulfilled","onRejected","getUri","eject","h","transformData","throwIfCancellationRequested","throwIfRequested","fns","normalizedName","write","expires","secure","cookie","Date","toGMTString","RegExp","decodeURIComponent","remove","now","isAbsoluteURL","combineURLs","requestedURL","test","relativeURL","ignoreDuplicateOf","parsed","line","substr","originURL","msie","userAgent","urlParsingNode","resolveURL","href","setAttribute","protocol","host","search","hash","hostname","port","pathname","charAt","location","requestURL","pkg","deprecatedWarnings","currentVerArr","version","isOlderVersion","thanVersion","pkgVersionArr","destVer","isDeprecated","formatMessage","opt","warn","allowUnknown","TypeError","executor","resolvePromise","token","c","callback","arr"],"mappings":"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","file":"static/js/0.a297f427.chunk.js","sourcesContent":["'use strict';\n\nvar bind = require('./helpers/bind');\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return toString.call(val) === '[object Array]';\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return (typeof FormData !== 'undefined') && (val instanceof FormData);\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","//eslint-disable-next-line\nexport * as is from './validate'\nimport {throwError} from './throw'\n\nexport const isObject = (value: any) =>\n  typeof value === 'object' && value !== null\nexport const isFunction = (value: any) => typeof value === 'function'\n\nexport const assertObject = (value: any) => {\n  if (!isObject(value) && !isFunction(value))\n    throwError('expect first argument be an object') // or function\n}\n\nfunction assertNodeSetItem(value: any, method: string, valueName: string, reason: string) {\n  if ((!isObject(value) && !isFunction(value)) || (!('family' in value) && !('graphite' in value))) {\n    throwError(`${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`)\n  }\n}\nexport function assertNodeSet(value: any, method: string, valueName: string) {\n  if (Array.isArray(value)) {\n    for (let i = 0; i < value.length; i++) {\n      const item = value[i]\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, '')\n    }\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n","import {getValue, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value: any\n  template: any\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = () => regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}É”${sid}`\n  return sid\n}\n\nexport function withRegion(unit: any, cb: () => void) {\n  const unitMeta = getGraph(unit).meta\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: unitMeta.template || readTemplate(),\n    sidRoot: unitMeta.sidRoot || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?: any\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {\n      sidRoot: readSidRoot(sid),\n      name,\n      loc,\n      method,\n    },\n  })\n  return withRegion(sidNode, fn)\n}\n","import {Node, NodeUnit, Cmd, StateRef} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK, STORE} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\n\nconst arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => {\n  const result = []\n  if (Array.isArray(list)) {\n    for (let i = 0; i < list.length; i++) {\n      if (Array.isArray(list[i])) result.push(...(list[i] as any))\n      else result.push(list[i])\n    }\n  } else {\n    result.push(list)\n  }\n  return result.map(getGraph)\n}\nexport const addToReg = (\n  {hasRef, type, data}: any,\n  reg: Record<string, StateRef>,\n) => {\n  let store\n  if (hasRef) {\n    store = data.store\n    reg[store.id] = store\n  }\n  if (type === 'mov' && data.to === STORE) {\n    store = data.target\n    reg[store.id] = store\n  }\n}\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]: any}\n  meta?: {[name: string]: any}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  const reg: {[id: string]: StateRef} = {}\n  for (let i = 0; i < node.length; i++) {\n    const item = node[i]\n    if (!item) continue\n    seq.push(item)\n    addToReg(item, reg)\n  }\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n    reg,\n  }\n  for (let i = 0; i < links.length; i++) {\n    getOwners(links[i]).push(result)\n  }\n  for (let i = 0; i < owners.length; i++) {\n    getLinks(owners[i]).push(result)\n  }\n  for (let i = 0; i < sources.length; i++) {\n    sources[i].next.push(result)\n  }\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const FORK_COUNTER = 'forkInFlightCounter'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import {Node, NodeUnit} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getParent, getValue} from './getter'\nimport {\n  STORE,\n  EFFECT,\n  SAMPLER,\n  STACK,\n  BARRIER,\n  VALUE,\n  FILTER,\n  REG_A,\n} from './tag'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\ntype Stack = {\n  value: any\n  a: any\n  b: any\n  parent: Stack | null\n  node: Node\n  page: {[id: string]: any} | null\n  forkPage?: any\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]: any}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  const isSameType = a.v.type === b.v.type\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (isSameType && a.v.id > b.v.id) ||\n    /** if first node is \"sampler\" and second node is \"barrier\" */\n    (!isSameType && a.v.type === SAMPLER)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 5) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  queue.push({first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 5; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * second bucket is for \"barrier\" PriorityType (used in combine)\n       * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 2 || i === 3) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: {[id: string]: any} | null,\n  node: Node,\n  parent: Stack | null,\n  value: any,\n  forkPage: any | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      forkPage,\n    },\n    type,\n  )\nconst pushHeap = (idx: number, stack: Stack, type: PriorityTag, id = 0) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    //@ts-ignore\n    l: 0,\n    //@ts-ignore\n    r: 0,\n  }\n  /**\n   * second bucket is for \"barrier\" PriorityType (used in combine)\n   * and third bucket is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 2 || priority === 3) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case BARRIER:\n      return 2\n    case SAMPLER:\n      return 3\n    case EFFECT:\n      return 4\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set()\n\nlet isRoot = true\nexport let isWatch = false\nexport let currentPage: any = null\nexport let forkPage: any\nexport const setForkPage = (newForkPage: any) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: any) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: any, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nconst getPageRef = (page: any, node: Node, id: string) => {\n  const pageForRef = getPageForRef(page, id)\n  return (pageForRef ? pageForRef : node).reg[id]\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?: any\n  defer?: boolean\n  page?: any\n  forkPage?: any\n  stack?: Stack\n}): void\nexport function launch(unit: NodeUnit, payload?: any, upsert?: boolean): void\nexport function launch(unit: any, payload?: any, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {isRoot, currentPage, forkPage, isWatch}\n  isRoot = false\n  let stop\n  let skip\n  let node\n  let value\n  let page\n  let reg\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    reg = (page ? page : node).reg\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      const data = step.data\n      switch (step.type) {\n        case BARRIER: {\n          let id = data.barrierID\n          if (page) {\n            id = `${page.fullID}_${id}`\n          }\n          const priority = data.priority\n          if (stepn !== idx || type !== priority) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, id)\n            }\n            continue kernelLoop\n          }\n          barriers.delete(id)\n          break\n        }\n        case 'mov': {\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (!reg[data.store.id]) {\n                // if (!page.parent) {\n                stack.page = page = getPageForRef(page, data.store.id)\n                reg = page ? page.reg : node.reg\n                // }\n              }\n              // value = getPageRef(page, node, data.store.id).current\n              value = readRef(reg[data.store.id])\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, node, data.target.id).current = value\n              break\n          }\n          break\n        }\n        case 'check':\n          switch (data.type) {\n            case 'defined':\n              skip = getValue(stack) === undefined\n              break\n            case 'changed':\n              skip =\n                getValue(stack) ===\n                readRef(getPageRef(page, node, data.store.id))\n              break\n          }\n          break\n        case FILTER:\n          /**\n           * handled edge case: if step.fn will throw,\n           * tryRun will return null\n           * thereby forcing that branch to stop\n           */\n          skip = !tryRun(local, data, stack)\n          break\n        case 'run':\n          /** exec 'compute' step when stepn === idx */\n          if (stepn !== idx || type !== EFFECT) {\n            pushHeap(stepn, stack, EFFECT)\n            continue kernelLoop\n          }\n        case 'compute':\n          isWatch = node.meta.op === 'watch'\n          stack.value = tryRun(local, data, stack)\n          isWatch = lastStartedState.isWatch\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      for (let stepn = 0; stepn < node.next.length; stepn++) {\n        pushFirstHeapItem(\n          'child',\n          page,\n          node.next[stepn],\n          stack,\n          getValue(stack),\n          getForkPage(stack),\n        )\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, {fn}: any, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import {Store, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent} from './getter'\n\nexport const joinName = (unit: any, tag: string) => '' + unit.shortName + tag\n\nexport const mapName = (unit: any, name?: string) =>\n  name == null ? joinName(unit, ' â†’ *') : name\n\nexport function unitObjectName(objOrArr: any, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  //@ts-ignore\n  for (const key in objOrArr) {\n    //@ts-ignore\n    const unit = objOrArr[key]\n    if (unit != null) {\n      name += comma\n      //@ts-ignore\n      name += is.unit(unit) ? unit.compositeName.fullName : unit.toString()\n    }\n    i += 1\n    /* inlined max object names constant */\n    if (i === 25) break\n    comma = ', '\n  }\n  name += ')'\n  return name\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  const compositeName = createName(rawName, getParent(store))\n  store.shortName = rawName\n  if (!store.compositeName) {\n    store.compositeName = compositeName\n    return\n  }\n  const currentComposite = store.compositeName\n  currentComposite.path = compositeName.path\n  currentComposite.shortName = compositeName.shortName\n  currentComposite.fullName = compositeName.fullName\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  let composite\n  const shortName = name\n  if (!parent) {\n    if (name.length === 0) {\n      path = []\n    } else {\n      path = [name]\n    }\n    fullName = name\n  } else {\n    composite = parent.compositeName\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      if (composite.fullName.length === 0) {\n        fullName = name\n      } else {\n        fullName = '' + composite.fullName + '/' + name\n      }\n    }\n  }\n  return {shortName, fullName, path}\n}\n","export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = (list: any[], item: any) => list.includes(item)\n\nexport const removeItem = (list: any[], item: any) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list: any, fn: Function) {\n  list.forEach(fn)\n}\n","import {observableSymbol} from './observable'\n\nimport {is, isObject, isFunction, assertObject, assertNodeSet} from './is'\nimport {Store, Event} from './unit.h'\n\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {bind} from './bind'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, currentPage, forkPage, setCurrentPage} from './kernel'\n\nimport {Subscriber, Config} from './index.h'\nimport {createName, mapName, joinName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getConfig,\n  getNestedConfig,\n  getStoreState,\n  getGraph,\n  getParent,\n} from './getter'\nimport {includes} from './collection'\nimport {throwError} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, REG_A} from './tag'\n\nconst normalizeConfig = (part: any, config: any) => {\n  if (isObject(part)) {\n    normalizeConfig(getConfig(part), config)\n    if (part.name != null) {\n      if (isObject(part.name)) normalizeConfig(part.name, config)\n      else if (isFunction(part.name)) config.handler = part.name\n      else config.name = part.name\n    }\n    if (part.loc) config.loc = part.loc\n    if (part.sid || part.sid === null) config.sid = part.sid\n    if (part.handler) config.handler = part.handler\n    if (part.updateFilter) config.updateFilter = part.updateFilter\n    if (getParent(part)) config.parent = getParent(part)\n    if ('strict' in part) config.strict = part.strict\n    if (part.named) config.named = part.named\n    normalizeConfig(getNestedConfig(part), config)\n  }\n  return config\n}\n\nexport const applyParentHook = (\n  source: any,\n  target: any,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nlet isStrict: boolean\nexport const initUnit = (\n  kind: any,\n  unit: any,\n  rawConfigA: any,\n  rawConfigB?: any,\n) => {\n  const config = normalizeConfig(\n    {\n      name: rawConfigB,\n      config: rawConfigA,\n    },\n    {},\n  )\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  let {parent = null, sid = null, strict = true, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n\n  const meta: Record<string, any> = {\n    unit: unit.kind = kind,\n    name: unit.shortName = name,\n    sid: unit.sid = readSidRoot(sid),\n    named,\n    unitId: unit.id = id,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => fn(unit)\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : (upd: any) => {\n              if (observer.next) {\n                observer.next(upd)\n              }\n            },\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  isStrict = strict\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst createComputation = (from: any, to: any, op: any, fn: Function) =>\n  createLinkNode(from, to, {\n    scope: {fn},\n    node: [step.compute({fn: callStack})],\n    meta: {op},\n  })\n\nconst createEventFiltration = (event: any, op: string, fn: any, node: any) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent(joinName(event, ' â†’? *'), config)\n  createLinkNode(event, mapped, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n  return mapped\n}\n\nfunction callCreate(unit: any, template: any, payload: any, args: any[]): any {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?: any,\n  maybeConfig?: any,\n): Event<Payload> {\n  const event: any = (payload: Payload, ...args: any[]) => {\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }\n  event.graphite = createNode({\n    meta: initUnit(EVENT, event, maybeConfig, nameOrConfig),\n    regional: true,\n  })\n  //eslint-disable-next-line no-unused-vars\n  event.create = (params: any, _: any) => {\n    const target = forkPage ? forkPage.find(event) : event\n    launch(target, params)\n    return params\n  }\n  event.watch = bind(watchUnit, event)\n  event.map = (fn: any) => {\n    let config\n    let name\n    if (isObject(fn)) {\n      config = fn\n      name = fn.name\n      fn = fn.fn\n    }\n    const mapped = createEvent(mapName(event, name), config)\n    createComputation(event, mapped, MAP, fn)\n    return mapped\n  }\n  event.filter = (fn: any) =>\n    createEventFiltration(event, FILTER, fn.fn ? fn : fn.fn, [\n      step.filter({fn: callStack}),\n    ])\n  event.filterMap = (fn: any) =>\n    createEventFiltration(event, 'filterMap', fn, [\n      step.compute({fn: callStack}),\n      step.check.defined(),\n    ])\n  event.prepend = (fn: any) => {\n    const contramapped: Event<any> = createEvent('* â†’ ' + event.shortName, {\n      parent: getParent(event),\n    })\n    const template = readTemplate()\n    if (template) {\n      getGraph(contramapped).seq.push(template.upward)\n    }\n    createComputation(contramapped, event, 'prepend', fn)\n    applyParentHook(event, contramapped)\n    return contramapped\n  }\n  const template = readTemplate()\n  return event\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const oldState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  const template = readTemplate()\n  plainState.after = [{type: 'copy', to: oldState}]\n  if (template) {\n    template.plain.push(plainState, oldState)\n  }\n  const plainStateId = plainState.id\n  const store: any = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage && forkPage.reg[plainStateId]) {\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState(state: any) {\n      let target\n      if (forkPage) {\n        target = forkPage.nodeMap[getGraph(store).id]\n      }\n      if (!target) target = store\n      launch({\n        target,\n        params: state,\n        defer: true,\n      })\n    },\n    reset(...units: any[]) {\n      for (const unit of units) store.on(unit, () => store.defaultState)\n      return store\n    },\n    on(nodeSet: any, fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      if (Array.isArray(nodeSet)) {\n        for (const event of nodeSet) {\n          onEvent(event, fn)\n        }\n      } else {\n        onEvent(nodeSet, fn)\n      }\n      return store\n    },\n    off(unit: any) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: any, firstState?: any) {\n      let config\n      let name\n      if (isObject(fn)) {\n        config = fn\n        name = fn.name\n        firstState = fn.firstState\n        fn = fn.fn\n      }\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (storeState !== undefined) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: mapName(store, name),\n        config,\n        strict: false,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, false, fn)\n\n      getStoreState(innerStore).before = [\n        {\n          type: MAP,\n          fn,\n          from: plainState,\n        },\n      ]\n      if (template) {\n        if (!includes(template.plain, plainState)) {\n          if (!includes(linkNode.seq, template.loader)) {\n            linkNode.seq.unshift(template.loader)\n          }\n        }\n      }\n      return innerStore\n    },\n    watch(eventOrFn: any, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        const template = readTemplate()\n        if (template) {\n          template.watch.push({\n            of: plainState,\n            fn: eventOrFn,\n          })\n        } else {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      if (!isFunction(fn)) throwError('second argument should be a function')\n      return eventOrFn.watch((payload: any) => fn(store.getState(), payload))\n    },\n  }\n  function onEvent(event: any, fn: Function) {\n    store.off(event)\n    getSubscribers(store).set(\n      event,\n      createSubscription(\n        updateStore(event, store, 'on', true, fn, updateFilter),\n      ),\n    )\n  }\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState},\n    node: [\n      step.check.defined(),\n      step.check.changed({\n        store: oldState,\n      }),\n      updateFilter && step.mov({store: oldState, to: REG_A}),\n      updateFilter &&\n        step.filter({\n          fn: (update, _, {a}) => updateFilter(update, a),\n        }),\n      step.update({\n        store: plainState,\n      }),\n      step.update({\n        store: oldState,\n      }),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  if (isStrict && defaultState === undefined)\n    throwError(\"current state can't be undefined, use null instead\")\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: any,\n  store: Store<any>,\n  op: string,\n  stateFirst: boolean,\n  fn: Function,\n  updateFilter?: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const node = [\n    step.mov({store: storeRef, to: REG_A}),\n    step.compute({\n      fn: stateFirst ? callARegStack : callStackAReg,\n    }),\n    step.check.defined(),\n    step.check.changed({store: storeRef}),\n    updateFilter &&\n      step.filter({\n        fn: (update, _, {a}) => updateFilter(update, a),\n      }),\n    step.update({store: storeRef}),\n  ]\n  const template = readTemplate()\n  if (template) {\n    node.unshift(template.loader)\n    node.push(template.upward)\n    if (is.store(from)) {\n      const ref = getStoreState(from)\n      if (!includes(template.plain, ref)) {\n        //if (!includes(node, template.loader)) {\n        //  node.unshift(template.loader)\n        //}\n        if (!includes(template.closure, ref)) {\n          template.closure.push(ref)\n        }\n        if (!storeRef.before) storeRef.before = []\n        storeRef.before.push({\n          type: 'closure',\n          of: ref,\n        })\n      }\n    } else {\n      //if (!includes(node, template.loader)) {\n      //  node.unshift(template.loader)\n      //}\n    }\n  }\n  return createLinkNode(from, store, {\n    scope: {fn},\n    node,\n    meta: {op},\n  })\n}\n","import {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef} from './stateRef'\nimport {step} from './typedef'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {is, isFunction, isObject} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {throwError} from './throw'\nimport {readTemplate} from './region'\nimport {forIn, includes} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\n\nexport function combine(...args: any[]): Store<any> {\n  let handler\n  let stores\n  let config\n  onConfigNesting(args[0], (injectedData, userConfig) => {\n    config = injectedData\n    args = userConfig\n  })\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      handler = spreadArgs(handler)\n    }\n  }\n  if (!isObject(structStoreShape)) throwError('shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst spreadArgs = (fn: Function) => (list: any[]) => fn(...list)\n\nconst storeCombination = (\n  isArray: boolean,\n  obj: any,\n  config?: string,\n  fn?: (upd: any) => any,\n) => {\n  const clone = isArray ? (list: any) => list.slice() : (obj: any) => ({...obj})\n  const defaultState: any = isArray ? [] : {}\n  const template = readTemplate()\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  if (template) {\n    template.plain.push(rawShape, isFresh)\n  }\n  const store = createStore(stateNew, {\n    name: config ? config : unitObjectName(obj),\n  })\n  getGraph(store).meta.isCombine = true\n  const node = [\n    step.check.defined(),\n    step.mov({\n      store: rawShape,\n      to: REG_A,\n    }),\n    //prettier-ignore\n    step.filter({\n      fn: (upd, {key}, {a}) => upd !== a[key],\n    }),\n    step.mov({\n      store: isFresh,\n      to: 'b',\n    }),\n    step.compute({\n      fn(upd, {clone, key}, reg) {\n        if (reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n      },\n    }),\n    step.mov({\n      from: REG_A,\n      target: rawShape,\n    }),\n    step.mov({\n      from: VALUE,\n      store: false,\n      target: isFresh,\n    }),\n    step.barrier({priority: BARRIER}),\n    step.mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n    }),\n    step.mov({store: rawShape}),\n    fn && step.compute({fn}),\n    step.check.changed({\n      store: getStoreState(store),\n    }),\n  ]\n  const before: any[] = (rawShape.before = [])\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, {\n      scope: {key, clone},\n      node,\n      meta: {op: 'combine'},\n    })\n    const childRef = getStoreState(child)\n    before.push({\n      type: 'field',\n      field: key,\n      from: childRef,\n    })\n    if (template) {\n      if (!includes(template.plain, childRef)) {\n        linkNode.seq.unshift(template.loader)\n      }\n    }\n  })\n\n  store.defaultShape = obj\n  rawShape.after = [\n    fn\n      ? {\n          type: MAP,\n          to: getStoreState(store),\n          fn,\n        }\n      : {\n          type: 'copy',\n          to: getStoreState(store),\n        },\n  ]\n  if (!template) {\n    store.defaultState = fn\n      ? (getStoreState(store).current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n","export function createDefer(): {\n  rs: (value: any) => any\n  rj: (value: any) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value: any) => any\n    rj: (value: any) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import {step} from './typedef'\nimport {getForkPage, getGraph, getParent} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {throwError} from './throw'\nimport {EFFECT} from './tag'\n\nexport function createEffect<Payload, Done>(\n  nameOrConfig: any,\n  maybeConfig: any,\n) {\n  const instance: any = createEvent(nameOrConfig, maybeConfig)\n  let handler =\n    instance.defaultConfig.handler ||\n    (() => throwError(`no handler used in ${instance.getType()}`))\n  const node = getGraph(instance)\n  node.meta.onCopy = ['runner']\n  node.meta.unit = instance.kind = EFFECT\n  instance.use = (fn: Function) => {\n    if (!isFunction(fn)) throwError('.use argument should be a function')\n    handler = fn\n    return instance\n  }\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}: any) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}: any) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}: any) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}: any) => error,\n  }))\n\n  const effectRunner = createNode({\n    scope: {\n      getHandler: instance.use.getCurrent = () => handler,\n      finally: anyway,\n    },\n    node: [\n      step.run({\n        fn({params, req}, {finally: anyway, getHandler}, stack) {\n          const onResolve = onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          })\n          const onReject = onSettled({\n            params,\n            req,\n            ok: false,\n            anyway,\n            stack,\n          })\n          let result\n          try {\n            result = getHandler()(params)\n          } catch (err) {\n            return void onReject(err)\n          }\n          if (isObject(result) && isFunction(result.then)) {\n            result.then(onResolve, onReject)\n          } else {\n            onResolve(result)\n          }\n        },\n      }),\n    ],\n    meta: {\n      op: 'fx',\n      fx: 'runner',\n      onCopy: ['finally'],\n    },\n  })\n  node.scope.runner = effectRunner\n  node.seq.push(\n    step.compute({\n      fn(params, scope, stack) {\n        // empty stack means that this node was launched directly\n        if (!getParent(stack)) return params\n        return {\n          params,\n          req: {\n            rs(data: any) {},\n            rj(data: any) {},\n          },\n        }\n      },\n    }),\n    step.run({\n      fn(upd, {runner}, stack) {\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          forkPage: getForkPage(stack),\n        })\n        return upd.params\n      },\n    }),\n  )\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch(forkPage.find(instance), payload)\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n\n  const pending = (instance.pending = inFlight.map({\n    //@ts-ignore\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [\n    anyway,\n    done,\n    fail,\n    doneData,\n    failData,\n    pending,\n    inFlight,\n    effectRunner,\n  ])\n  return instance\n}\n\nexport const onSettled = ({\n  params,\n  req,\n  ok,\n  anyway,\n  stack,\n}: {\n  params: any\n  req: {\n    rs(_: any): any\n    rj(_: any): any\n  }\n  ok: boolean\n  anyway: any\n  stack: any\n}) => (data: any) =>\n  launch({\n    target: [anyway, sidechain],\n    params: [\n      ok\n        ? {\n            status: 'done',\n            params,\n            result: data,\n          }\n        : {\n            status: 'fail',\n            params,\n            error: data,\n          },\n      {\n        fn: ok ? req.rs : req.rj,\n        value: data,\n      },\n    ],\n    defer: true,\n    page: stack.page,\n    forkPage: getForkPage(stack),\n  })\n\nexport const sidechain = createNode({\n  node: [\n    step.run({\n      fn({fn, value}) {\n        fn(value)\n      },\n    }),\n  ],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import {combine} from './combine'\nimport {createEffect, onSettled} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {onConfigNesting} from './config'\nimport {getGraph, getStoreState} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {step} from './typedef'\nimport {launch} from './kernel'\nimport {addToReg} from './createNode'\nimport {STORE, EFFECT, REG_A} from './tag'\n\nexport function attach(config: any) {\n  let injected\n  onConfigNesting(config, (injectedData, userConfig) => {\n    injected = injectedData\n    config = userConfig\n  })\n  let {source, effect, mapParams} = config\n  if (!mapParams)\n    mapParams = source\n      ? (_: any, source: any) => source\n      : (params: any) => params\n  const attached = createEffect(config, injected)\n  const {runner} = getGraph(attached).scope\n\n  let runnerSteps\n  const runnerFn = (\n    {params, req}: any,\n    {finally: anyway, effect}: any,\n    stack: any,\n  ) => {\n    const rj = onSettled({\n      params,\n      req,\n      ok: false,\n      anyway,\n      stack,\n    })\n    let computedParams\n    try {\n      computedParams = mapParams(params, stack.a)\n    } catch (err) {\n      return rj(err)\n    }\n    launch({\n      target: effect,\n      params: {\n        params: computedParams,\n        req: {\n          rs: onSettled({\n            params,\n            req,\n            ok: true,\n            anyway,\n            stack,\n          }),\n          rj,\n        },\n      },\n      page: stack.page,\n      defer: true,\n    })\n  }\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(source, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    const readStateRef = step.mov({\n      from: STORE,\n      store: getStoreState(state),\n      to: REG_A,\n    })\n    runnerSteps = [\n      /* let another side-effects run first */\n      step.run({fn: _ => _}),\n      /* read state. assumed it already stable here because of previous step */\n      readStateRef,\n      /* no need for step.run because of first step */\n      step.compute({fn: runnerFn}),\n    ]\n    addToReg(readStateRef, runner.reg)\n  } else {\n    runnerSteps = [step.run({fn: runnerFn})]\n  }\n  own(effect, [attached])\n  runner.scope.effect = effect\n  runner.meta.onCopy.push(EFFECT)\n  runner.seq.splice(0, 1, ...runnerSteps)\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import {Store, Event, Effect, Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {forward} from './forward'\nimport {forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {step} from './typedef'\n\nconst createHook = (trigger: Event<any>, acc: Set<any>, node: any) => {\n  trigger.create = res => {\n    launch(trigger, res)\n    return res\n  }\n  getGraph(trigger).seq.push(\n    step.compute({\n      fn(upd, _, stack) {\n        stack.forkPage = null\n        return upd\n      },\n    }),\n  )\n  trigger.watch(data => {\n    own(node, [data])\n    acc.add(data)\n    if (!data.ownerSet) data.ownerSet = acc\n    if (!getParent(data)) data.parent = node\n  })\n  own(node, [trigger])\n  return (hook: (data: any) => any) => {\n    acc.forEach(hook)\n    return trigger.watch(hook)\n  }\n}\n\nexport function createDomain(nameOrConfig: any, maybeConfig?: any): Domain {\n  const domains: Set<Domain> = new Set()\n  const stores: Set<Store<any>> = new Set()\n  const effects: Set<Effect<any, any, any>> = new Set()\n  const events: Set<Event<any>> = new Set()\n\n  const node = createNode({\n    family: {type: DOMAIN},\n    regional: true,\n  })\n\n  const result: any = {\n    history: {\n      domains,\n      stores,\n      effects,\n      events,\n    },\n    graphite: node,\n  }\n\n  node.meta = initUnit(DOMAIN, result, maybeConfig, nameOrConfig)\n  const [event, effect, store, domain] = [\n    'onEvent',\n    'onEffect',\n    'onStore',\n    'onDomain',\n  ].map(createNamedEvent)\n\n  result.hooks = {\n    event,\n    effect,\n    store,\n    domain,\n  }\n  result.onCreateEvent = createHook(event, events, result)\n  result.onCreateEffect = createHook(effect, effects, result)\n  result.onCreateStore = createHook(store, stores, result)\n  result.onCreateDomain = createHook(domain, domains, result)\n\n  result.createEvent = result.event = (nameOrConfig: any, config?: Config) =>\n    event(\n      createEvent(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createEffect = result.effect = (nameOrConfig: any, config?: Config) =>\n    effect(\n      createEffect(nameOrConfig, {\n        parent: result,\n        config,\n      }),\n    )\n  result.createDomain = result.domain = (nameOrConfig: any, config?: Config) =>\n    createDomain({\n      name: nameOrConfig,\n      parent: result,\n      config,\n    })\n  result.createStore = result.store = (state: any, config?: Config) =>\n    store(\n      createStore(state, {\n        parent: result,\n        config,\n      }),\n    )\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) => {\n      forward({from, to: parent.hooks[key]})\n    })\n    parent.hooks.domain(result)\n  }\n  return result\n}\n","import {observableSymbol} from './observable'\nimport {Event} from './unit.h'\nimport {clearNode} from './clearNode'\nimport {createEvent} from './createUnit'\nimport {bind2} from './bind'\nimport {assertObject} from './is'\nimport {throwError} from './throw'\n\nexport function fromObservable<T>(observable: any): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  if (!observableItem.subscribe)\n    throwError('expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = bind2(clearNode, event, undefined)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {forward} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  events: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  const result = createEvent(config || unitObjectName(events, 'merge'))\n  assertNodeSet(events, 'merge', 'first argument')\n  forward({\n    from: events,\n    to: result,\n    meta: {op: 'merge'},\n  })\n  return result\n}\n","import {combine} from './combine'\nimport {step} from './typedef'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg, callARegStack} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {own} from './own'\nimport {assertNodeSet, is, isObject} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {createNode} from './createNode'\nimport {readTemplate} from './region'\nimport {throwError} from './throw'\nimport {includes, forEach} from './collection'\nimport {REG_A, SAMPLE, SAMPLER, STACK, STORE, VALUE} from './tag'\nimport {merge} from './merge'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nfunction validateSampleConfig(config: any) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      if (config[field] == null) {\n        throwError(`sample: ${field} should be defined`)\n      }\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args: any): any {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let greedy\n  //config case\n  if (clock === undefined && isObject(source) && validateSampleConfig(source)) {\n    clock = source.clock\n    fn = source.fn\n    greedy = source.greedy\n    //optional target & name accepted only from config\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'sample', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) {\n    source = combine(source)\n  }\n  if (clock === undefined) {\n    //still undefined!\n    clock = source\n  }\n  assertNodeSet(clock, 'sample', 'clock')\n  name = metadata || name || source.shortName\n  const template = readTemplate()\n  const isUpward = !!target\n  if (!target) {\n    if (is.store(source) && is.store(clock)) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid})\n    } else {\n      target = createEvent(name)\n      if (template) {\n        getGraph(target).seq.push(template.loader)\n      }\n    }\n  }\n  const targetTemplate =\n    isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  if (is.store(source)) {\n    const sourceRef = getStoreState(source)\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {fn, targetTemplate},\n        node: [\n          template && template.loader,\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({\n            store: sourceRef,\n            to: fn ? REG_A : STACK,\n          }),\n          fn && step.compute({fn: callARegStack}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: STORE},\n      }),\n    ])\n    if (template) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    }\n  } else {\n    const hasSource = createStateRef(false)\n    const sourceState = createStateRef()\n    const clockState = createStateRef()\n    if (template) {\n      template.plain.push(hasSource, sourceState, clockState)\n    }\n    createNode({\n      parent: source,\n      node: [\n        step.update({store: sourceState}),\n        step.mov({\n          from: VALUE,\n          store: true,\n          target: hasSource,\n        }),\n      ],\n      family: {\n        owners: [source, target, clock],\n        links: target,\n      },\n      meta: {op: SAMPLE, sample: 'source'},\n      regional: true,\n    })\n    own(source, [\n      createLinkNode(clock, target, {\n        scope: {\n          fn,\n          targetTemplate,\n        },\n        node: [\n          template && template.loader,\n          step.update({store: clockState}),\n          step.mov({store: hasSource}),\n          step.filter({fn: hasSource => hasSource}),\n          //@ts-ignore\n          !greedy && step.barrier({priority: SAMPLER}),\n          step.mov({store: sourceState}),\n          step.mov({\n            store: clockState,\n            to: REG_A,\n          }),\n          fn && step.compute({fn: callStackAReg}),\n          template && isUpward && template.upward,\n        ],\n        meta: {op: SAMPLE, sample: 'clock'},\n      }),\n    ])\n  }\n  return target\n}\n","import {processArgsToConfig} from './config'\nimport {createLinkNode} from './forward'\nimport {sample} from './sample'\nimport {createEvent} from './createUnit'\nimport {combine} from './combine'\nimport {step} from './typedef'\nimport {callStack} from './caller'\nimport {assertNodeSet, is, isFunction} from './is'\nimport {createNode} from './createNode'\nimport {throwError} from './throw'\nimport {merge} from './merge'\n\nexport function guard(...args: any[]) {\n  const meta: Record<string, any> = {op: 'guard'}\n  let rawName = 'guard'\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (metadata) {\n    meta.config = metadata\n    if (metadata.name) rawName = metadata.name\n  }\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  let {filter, greedy, clock, name = rawName} = config\n  const target = config.target || createEvent(name, meta.config)\n  const filterIsUnit = is.unit(filter)\n  let needToCombine = true\n  if (source === undefined) {\n    assertNodeSet(clock, 'guard', 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock)\n    }\n    source = clock\n    needToCombine = false\n  }\n  if (needToCombine && !is.unit(source)) source = combine(source)\n  if (clock) {\n    assertNodeSet(clock, 'guard', 'clock')\n    source = sample({\n      source,\n      clock,\n      greedy,\n      fn: filterIsUnit ? null : (source: any, clock: any) => ({source, clock}),\n    })\n  }\n  assertNodeSet(target, 'guard', 'target')\n  if (filterIsUnit) {\n    sample({\n      source: filter,\n      clock: source,\n      target: createNode({\n        node: [\n          step.filter({\n            fn: ({guard}) => guard,\n          }),\n          step.compute({\n            fn: ({data}) => data,\n          }),\n        ],\n        child: target,\n        meta,\n        family: {\n          owners: [source, filter, target, ...[].concat(clock ? clock : [])],\n          links: target,\n        },\n        regional: true,\n      }),\n      fn: (guard: any, data: any) => ({guard, data}),\n      greedy,\n      name,\n    })\n  } else {\n    if (!isFunction(filter)) throwError('`filter` should be function or unit')\n    createLinkNode(source, target, {\n      scope: {fn: filter},\n      node: clock\n        ? [\n            step.filter({\n              fn: ({source, clock}, {fn}) => fn(source, clock),\n            }),\n            step.compute({\n              fn: ({source}) => source,\n            }),\n          ]\n        : [step.filter({fn: callStack})],\n      meta,\n    })\n  }\n  return target\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\n\nexport function restore(obj: any, defaultState: any, config?: any): any {\n  if (is.store(obj)) {\n    return obj\n  }\n  if (is.unit(obj)) {\n    const domain = getParent(obj)\n    let result\n    if (is.event(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        É”: config,\n      }).on(obj, (_, v) => v)\n    }\n    if (is.effect(obj)) {\n      result = createStore(defaultState, {\n        parent: domain,\n        name: obj.shortName,\n        É”: config,\n      }).on(obj.done, (_: any, {result}: any) => result)\n    }\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(obj, (value, key) => {\n    result[key] = is.store(value) ? value : createStore(value, {name: key})\n  })\n  return result\n}\n","import {Event} from './unit.h'\nimport {NodeUnit, Cmd} from './index.h'\nimport {is, isFunction, isObject} from './is'\nimport {forIn, includes} from './collection'\nimport {createStateRef} from './stateRef'\nimport {readTemplate} from './region'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {step} from './typedef'\nimport {createNode} from './createNode'\nimport {launch} from './kernel'\nimport {getStoreState} from './getter'\nimport {REG_A} from './tag'\nimport {throwError} from './throw'\nimport {createEvent} from './createUnit'\n\nconst launchCase = (\n  scopeTargets: Record<string, NodeUnit>,\n  field: string,\n  data: any,\n  stack: any,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args: any[]): any {\n  let targets: Record<string, Event<any> | NodeUnit>\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const knownCases = !match\n  if (knownCases) {\n    targets = source.cases\n    match = source.match\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!knownCases) {\n    if (!matchIsShape) throwError('match should be an object')\n    forIn(match, (_, key) => {\n      //@ts-ignore\n      targets[key] = createEvent(metadata)\n    })\n    targets.__ = createEvent(metadata)\n  }\n  //@ts-ignore\n  const template = readTemplate()\n  const owners = new Set(\n    ([] as NodeUnit[]).concat(source, Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && step.barrier({priority: 'sampler'}),\n      matchIsUnit &&\n        step.mov({\n          store: getStoreState(match),\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const before: any[] = (lastValues.before = [])\n    const updaterSteps = [\n      step.mov({\n        store: lastValues,\n        to: REG_A,\n      }),\n      step.compute({\n        fn(upd, {key}, {a}) {\n          a[key] = upd\n        },\n      }),\n    ]\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn: any, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        units.push(key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(storeOrFn, [], {\n          node: updaterSteps,\n          scope: {key},\n        })\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          before.push({\n            type: 'field',\n            field: key,\n            from: storeRef,\n          })\n          if (template) {\n            if (!includes(template.plain, storeRef)) {\n              updater.seq.unshift(template.loader)\n            }\n          }\n        }\n      }\n    })\n    if (needBarrier! && template) {\n      template.plain.push(lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && step.barrier({priority: 'sampler'}),\n      needBarrier! &&\n        step.mov({\n          store: lastValues,\n          to: 'a',\n        }),\n      step.filter({\n        fn(data, scopeTargets, stack) {\n          for (let i = 0; i < caseNames.length; i++) {\n            const caseName = caseNames[i]\n            const caseValue = includes(units, caseName)\n              ? stack.a[caseName]\n              : match[caseName](data)\n            if (caseValue) {\n              launchCase(scopeTargets, caseName, data, stack)\n              return\n            }\n          }\n          launchCase(scopeTargets, '__', data, stack)\n        },\n      }),\n    ]\n  } else {\n    throwError('expect match to be unit, function or object')\n  }\n  createNode({\n    meta: {\n      onCopy: Object.keys(targets),\n      op: 'split',\n    },\n    parent: source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {\n      type: 'crosslink',\n      owners: Array.from(owners),\n    },\n    regional: true,\n  })\n  if (!knownCases) return targets\n}\n","import {getForkPage, getGraph, getLinks, getOwners, getParent} from './getter'\nimport {bind} from './bind'\nimport {createDefer} from './defer'\nimport {watchUnit} from './watch'\nimport {is, isObject} from './is'\nimport {throwError} from './throw'\nimport {launch, forkPage, setForkPage, currentPage} from './kernel'\nimport {createNode} from './createNode'\nimport {step} from './typedef'\nimport {Domain, Store} from './unit.h'\nimport {Node, StateRef} from './index.h'\nimport {removeItem, forEach, includes, forIn} from './collection'\nimport {DOMAIN, STORE, EVENT, EFFECT, SAMPLER, MAP, FORK_COUNTER} from './tag'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain, {values}: {values: any}) {\n  const isScope = isObject(domain) && (domain as any).cloneOf\n  if (!is.domain(domain) && !isScope) {\n    throwError('first argument of hydrate should be domain or scope')\n  }\n  if (!isObject(values)) {\n    throwError('values property should be an object')\n  }\n  const normalizedValues = normalizeValues(values)\n  let storeWatches: Node[]\n  let storeWatchesRefs: any[]\n  if (isScope) {\n    storeWatches = []\n    storeWatchesRefs = []\n    forIn(normalizedValues, (val, sid) => {\n      //@ts-ignore\n      const node = domain.sidMap[sid]\n      if (node) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(val)\n        ;(domain as any).changedStores.add(node.meta.forkOf.id)\n      }\n    })\n  } else {\n    const fillResult = fillValues({\n      flatGraphUnits: flatGraph(domain),\n      values: normalizedValues,\n      collectWatches: true,\n    })\n    storeWatches = fillResult.storeWatches\n    storeWatchesRefs = fillResult.storeWatchesRefs.map(({current}) => current)\n  }\n\n  launch({\n    target: storeWatches,\n    params: storeWatchesRefs,\n    forkPage: isScope ? domain : false,\n  })\n}\n\nfunction fillValues({\n  flatGraphUnits,\n  values,\n  collectWatches,\n}: {\n  flatGraphUnits: Node[]\n  values: Record<string, any>\n  collectWatches: boolean\n}) {\n  const storeWatches: Node[] = []\n  const storeWatchesRefs: StateRef[] = []\n  const refsMap = {} as Record<string, StateRef>\n  const predefinedRefs = new Set()\n  const valuesSidList = Object.getOwnPropertyNames(values)\n  forEach(flatGraphUnits, node => {\n    const {reg} = node\n    const {op, unit, sid} = node.meta\n    if (unit === STORE) {\n      if (sid && includes(valuesSidList, sid)) {\n        const {state} = node.scope\n        state.current = values[sid]\n        predefinedRefs.add(state)\n      }\n    }\n    if (collectWatches && op === 'watch') {\n      const owner = node.family.owners[0]\n      if (owner.meta.unit === STORE) {\n        storeWatches.push(node)\n        storeWatchesRefs.push(owner.scope.state)\n      }\n    }\n    forIn(reg, (ref, id) => {\n      refsMap[id] = ref\n    })\n  })\n  const refGraph = createRefGraph(refsMap)\n  const result = toposort(refGraph)\n  forEach(result, id => {\n    execRef(refsMap[id])\n  })\n\n  return {\n    storeWatches,\n    storeWatchesRefs,\n  }\n\n  function execRef(ref: StateRef) {\n    let isFresh = false\n    if (ref.before && !predefinedRefs.has(ref)) {\n      forEach(ref.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            ref.current = cmd.fn(from.current)\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            ref.current[cmd.field] = from.current\n            break\n          }\n          case 'closure':\n            break\n        }\n      })\n    }\n    if (!ref.after) return\n    const value = ref.current\n    forEach(ref.after, cmd => {\n      const to = cmd.to\n      // if (predefinedRefs.has(to)) continue\n      switch (cmd.type) {\n        case 'copy':\n          to.current = value\n          break\n        case MAP:\n          to.current = cmd.fn(value)\n          break\n      }\n    })\n  }\n}\n\nfunction createRefGraph(refsMap: Record<string, StateRef>) {\n  const items = Object.values(refsMap)\n  const refGraph = {} as Record<string, string[]>\n  forEach(items, ({id}) => {\n    refGraph[id] = []\n  })\n  //prettier-ignore\n  forEach(items, ({id, before, after}) => {\n    before && forEach(before, cmd => {\n      refGraph[cmd.from.id].push(id)\n    })\n    after && forEach(after, cmd => {\n      refGraph[id].push(cmd.to.id)\n    })\n  })\n  return refGraph\n}\n\n/**\n serialize state on server\n */\nexport function serialize(\n  {clones, changedStores}: any,\n  {\n    ignore = [],\n    onlyChanges,\n  }: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const result = {} as Record<string, any>\n  forEach(clones, ({meta, scope, reg}) => {\n    if (meta.unit !== STORE) return\n    const {sid} = meta\n    if (!sid) return\n    if (onlyChanges || meta.isCombine) {\n      if (!changedStores.has(meta.forkOf.id)) return\n    }\n    result[sid] = reg[scope.state.id].current\n  })\n  forEach(ignore, ({sid}) => {\n    if (sid) delete result[sid]\n  })\n  return result\n}\n\n/** bind event to scope */\nexport function scopeBind(unit: any) {\n  if (!forkPage) {\n    throwError('scopeBind cannot be called outside of forked .watch')\n  }\n  const savedForkPage = forkPage\n  const localUnit = forkPage.find(unit)\n  return is.effect(unit)\n    ? (params: any) => {\n        const req = createDefer()\n        launch({\n          target: localUnit,\n          params: {\n            params,\n            req,\n          },\n          forkPage: savedForkPage,\n        })\n      }\n    : (params: any) => {\n        launch({target: localUnit, params, forkPage: savedForkPage})\n        return params\n      }\n}\n\nfunction normalizeValues(\n  values: Map<Store<any>, any> | Record<string, any>,\n  assertEach = (key: any, value: any) => {},\n) {\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    for (const [key, value] of values) {\n      if (!is.unit(key)) throwError('Map key should be a unit')\n      assertEach(key, value)\n      result[key.sid!] = value\n    }\n    return result\n  }\n  return values\n}\n\nexport function fork(\n  domain: Domain,\n  {values, handlers}: {values?: any; handlers?: any} = {},\n) {\n  if (!is.domain(domain)) throwError('first argument of fork should be domain')\n  const needToFill = !!values\n  values = normalizeValues(\n    values || {},\n    unit =>\n      !is.store(unit) &&\n      throwError('Values map can contain only stores as keys'),\n  )\n  const forked = cloneGraph(domain)\n  if (needToFill) {\n    fillValues()\n  }\n  if (handlers) {\n    handlers = normalizeValues(\n      handlers,\n      unit =>\n        !is.effect(unit) &&\n        throwError(`Handlers map can contain only effects as keys`),\n    )\n    const handlerKeys = Object.keys(handlers)\n    forEach(forked.clones, ({scope, meta}) => {\n      if (meta.sid && includes(handlerKeys, meta.sid)) {\n        scope.runner.scope.getHandler = () => handlers[meta.sid]\n      }\n    })\n  }\n  return forked\n\n  function fillValues() {\n    const sourceList = flatGraph(domain)\n    const sourceRefsMap = {} as Record<string, StateRef>\n    const refsMap = {} as Record<string, StateRef>\n    const predefinedRefs = new Set()\n    const templateOwnedRefs = new Set<string>()\n    const valuesSidList = Object.getOwnPropertyNames(values)\n    forEach(sourceList, ({reg, meta}) => {\n      const {nativeTemplate} = meta\n      forIn(reg, (ref, id) => {\n        sourceRefsMap[id] = ref\n        if (nativeTemplate) {\n          templateOwnedRefs.add(id)\n        }\n      })\n    })\n    forEach(forked.clones, node => {\n      const {reg} = node\n      const {unit, sid} = node.meta\n      if (unit === STORE) {\n        if (sid && includes(valuesSidList, sid)) {\n          const {state} = node.scope\n          reg[state.id].current = values[sid]\n          predefinedRefs.add(state)\n          forked.changedStores.add(node.meta.forkOf.id)\n        }\n      }\n      forIn(reg, (ref, id) => {\n        refsMap[id] = ref\n      })\n    })\n    const refGraph = createRefGraph(sourceRefsMap)\n    const result = toposort(refGraph, templateOwnedRefs)\n    forEach(result, id => {\n      execRef(refsMap[id], sourceRefsMap[id])\n    })\n\n    function execRef(ref: StateRef, sourceRef?: StateRef) {\n      let isFresh = false\n      if (sourceRef && sourceRef.before && !predefinedRefs.has(ref)) {\n        forEach(sourceRef.before, cmd => {\n          switch (cmd.type) {\n            case MAP: {\n              const from = refsMap[cmd.from.id]\n              ref.current = cmd.fn(from.current)\n              break\n            }\n            case 'field': {\n              const from = refsMap[cmd.from.id]\n              if (!isFresh) {\n                isFresh = true\n                if (Array.isArray(ref.current)) {\n                  ref.current = [...ref.current]\n                } else {\n                  ref.current = {...ref.current}\n                }\n              }\n              ref.current[cmd.field] = from.current\n              break\n            }\n            case 'closure':\n              break\n          }\n        })\n      }\n      if (!sourceRef || !sourceRef.after) return\n      const value = ref.current\n      forEach(sourceRef.after, cmd => {\n        const to = refsMap[cmd.to.id]\n        // if (predefinedRefs.has(to)) continue\n        switch (cmd.type) {\n          case 'copy':\n            to.current = value\n            break\n          case MAP:\n            to.current = cmd.fn(value)\n            break\n        }\n      })\n    }\n  }\n}\n\nfunction toposort(rawGraph: Record<string, string[]>, ignore?: Set<string>) {\n  const graph = {} as Record<string, string[]>\n  for (const id in rawGraph) {\n    graph[id] = [...new Set(rawGraph[id])]\n  }\n  const result = [] as string[]\n  const visited = {} as Record<string, boolean>\n  const temp = {} as Record<string, boolean>\n  for (const node in graph) {\n    if (!visited[node] && !temp[node]) {\n      topologicalSortHelper(node)\n    }\n  }\n  result.reverse()\n  if (ignore && ignore.size > 0) {\n    const processed = [] as string[]\n    const ignored = [...ignore]\n    let item: string | void\n    while ((item = ignored.shift())) {\n      processed.push(item)\n      forEach(graph[item], child => {\n        if (includes(processed, child) || includes(ignored, child)) return\n        ignored.push(child)\n      })\n    }\n    forEach(processed, item => {\n      removeItem(result, item)\n    })\n  }\n  return result\n\n  function topologicalSortHelper(node: string) {\n    temp[node] = true\n    const neighbors = graph[node]\n    for (let i = 0; i < neighbors.length; i++) {\n      const n = neighbors[i]\n      if (temp[n]) {\n        continue\n        // throw Error('found cycle in DAG')\n      }\n      if (!visited[n]) {\n        topologicalSortHelper(n)\n      }\n    }\n    temp[node] = false\n    visited[node] = true\n    result.push(node)\n  }\n}\n\nexport function allSettled(\n  start: any,\n  {scope, params: ctx}: {scope: any; params?: any},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-ignore\n  defer.parentFork = forkPage\n  const {forkInFlightCounter} = scope.graphite.scope\n  forkInFlightCounter.scope.defers.push(defer)\n  const contextStart = scope.find(start)\n\n  const launchUnits = [contextStart]\n  const launchParams = []\n  if (is.effect(start)) {\n    launchParams.push({\n      params: ctx,\n      req: {\n        rs(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'done', value}\n        },\n        rj(value: any) {\n          //@ts-ignore\n          defer.value = {status: 'fail', value}\n        },\n      },\n    })\n  } else {\n    launchParams.push(ctx)\n  }\n  launchUnits.push(forkInFlightCounter)\n  launchParams.push(null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    forkPage: scope,\n  })\n  return defer.req\n}\n\nfunction flatGraph(unit: any) {\n  const list = [] as Node[]\n  ;(function traverse(node) {\n    if (includes(list, node)) return\n    list.push(node)\n    forEachRelatedNode(node, traverse)\n  })(getGraph(unit))\n  return list\n}\n\n/**\n everything we need to clone graph section\n reachable from given unit\n */\nfunction cloneGraph(unit: any) {\n  const list = flatGraph(unit)\n  const refs = new Map()\n  const scope = {\n    defers: [],\n    inFlight: 0,\n    fxID: 0,\n  }\n  const changedStores = new Set<string>()\n  const putStoreToChanged = step.compute({\n    fn(upd, _, stack) {\n      if (\n        !stack.node.meta.isCombine ||\n        (getParent(stack) && getParent(stack).node.meta.op !== 'combine')\n      )\n        changedStores.add(stack.node.meta.forkOf.id)\n      return upd\n    },\n  })\n  const forkInFlightCounter = createNode({\n    scope,\n    node: [\n      step.compute({\n        fn(_, scope, stack) {\n          if (!stack.parent) {\n            scope.fxID += 1\n            return\n          }\n          if (stack.parent.node.meta.named === 'finally') {\n            scope.inFlight -= 1\n          } else {\n            scope.inFlight += 1\n            scope.fxID += 1\n          }\n        },\n      }),\n      step.barrier({priority: SAMPLER}),\n      step.run({\n        fn(_, scope) {\n          const {inFlight, defers, fxID} = scope\n          if (inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), (defer: any) => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n      }),\n    ],\n    meta: {unit: FORK_COUNTER},\n  })\n  const nodeMap = {} as Record<string, Node>\n  const sidMap = {} as Record<string, Node>\n  const clones = list.map(node => {\n    const {seq, next, meta, scope} = node\n    const result = createNode({\n      node: seq.map(step => ({\n        id: step.id,\n        type: step.type,\n        data: {...step.data},\n        hasRef: step.hasRef,\n      })) as any,\n      child: [...next],\n      meta: {forkOf: node, ...meta},\n      scope: {...scope},\n    })\n    result.family = {\n      type: node.family.type,\n      links: [...getLinks(node)],\n      owners: [...getOwners(node)],\n    }\n    nodeMap[node.id] = result\n    if (meta.sid) sidMap[meta.sid] = result\n    return result\n  })\n  const page = {} as Record<string, StateRef>\n  forEach(clones, node => {\n    const {\n      reg,\n      scope,\n      meta: {onCopy, op, unit},\n    } = node\n    forIn(reg, (ref, id) => {\n      let newRef = refs.get(ref)\n      if (!newRef) {\n        newRef = {\n          id: ref.id,\n          current: ref.current, //ref.id in values ? values[ref.id] : ref.current,\n        }\n        refs.set(ref, newRef)\n      }\n      page[id] = reg[id] = newRef\n    })\n    if (onCopy) {\n      forEach(onCopy, (copyField: string) => {\n        const origValue = scope[copyField]\n        scope[copyField] = Array.isArray(origValue)\n          ? origValue.map(findClone)\n          : findClone(origValue)\n      })\n    }\n    forEachRelatedNode(node, (node, i, siblings) => {\n      siblings[i] = findClone(node)\n    })\n    const itemTag = op || unit\n    switch (itemTag) {\n      case STORE:\n        node.meta.wrapped = wrapStore(node)\n        if (node.meta.sid) node.seq.push(putStoreToChanged)\n        break\n      // case EVENT:\n      //   break\n      case EFFECT:\n        node.next.push(forkInFlightCounter)\n        break\n      case 'fx': {\n        scope.finally.next.push(forkInFlightCounter)\n        break\n      }\n      // case 'watch':\n      //   break\n    }\n  })\n\n  return {\n    cloneOf: unit,\n    changedStores,\n    nodeMap,\n    sidMap,\n    clones,\n    find: findClone,\n    reg: page,\n    getState: (store: any) => findClone(store).meta.wrapped.getState(),\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, ...clones],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n  }\n\n  function findClone(unit: any) {\n    const node = getGraph(unit)\n    const index = list.indexOf(node)\n    if (index === -1) {\n      let unitName = 'unit'\n      if (unit !== node && unit.id !== unit.shortName) unitName = unit.shortName\n      throwError(`${unitName} not found in forked scope`)\n    }\n    return clones[index]\n  }\n}\n\nfunction wrapStore(node: Node) {\n  return {\n    kind: STORE,\n    getState: () => node.reg[node.scope.state.id].current,\n    updates: {\n      watch: bind(watchUnit, node),\n    },\n    graphite: node,\n    family: node.family,\n  }\n}\n\nfunction forEachRelatedNode(\n  node: Node,\n  cb: (node: Node, index: number, siblings: Node[]) => void,\n) {\n  const unit = node.meta.unit\n  if (unit === 'fork' || unit === FORK_COUNTER) return\n  forEach(node.next, cb)\n  forEach(getOwners(node), cb)\n  forEach(getLinks(node), cb)\n}\n","export const observableSymbol: any =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT} from './tag'\nimport {isObject, isFunction} from './is'\n\nexport const unit = (obj: any) =>\n  (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => (obj: any) => unit(obj) && obj.kind === type\n\nexport const store = is(STORE)\nexport const event = is(EVENT)\nexport const effect = is(EFFECT)\nexport const domain = is(DOMAIN)\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","const idCount = () => {\n  let id = 0\n  return () => (++id).toString(36)\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","export const bind = (fn: Function, target: any) => fn.bind(null, target)\nexport const bind2 = (fn: Function, target: any, arg: any) =>\n  fn.bind(null, target, arg)\n","import {StateRef, Run, Filter, Compute, Barrier, Check, Mov} from './index.h'\nimport {nextStepID} from './id'\nimport {bind2} from './bind'\nimport {BARRIER, FILTER, STACK, STORE} from './tag'\n\nconst cmd = (type: any, hasRef: boolean, data: any): any => ({\n  id: nextStepID(),\n  type,\n  data,\n  hasRef,\n})\n\nlet nextBarrierID = 0\n\nexport const barrier: (data: {priority?: 'barrier' | 'sampler'}) => Barrier = ({\n  priority = BARRIER,\n}) =>\n  cmd(BARRIER, false, {\n    barrierID: ++nextBarrierID,\n    priority,\n  })\nexport const mov: (data: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: any\n  target?: any\n}) => Mov = ({from = STORE, store, target, to = target ? STORE : STACK}) =>\n  cmd('mov', from === STORE, {from, store, to, target})\nexport const check: {\n  defined(): Check\n  changed(config: {store: StateRef}): Check\n} = {\n  defined: () => cmd('check', false, {type: 'defined'}),\n  changed: ({store}) => cmd('check', true, {type: 'changed', store}),\n}\nexport const compute: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Compute = bind2(cmd, 'compute', false)\nexport const filter: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Filter = bind2(cmd, FILTER, false)\nexport const run: (data: {\n  fn: (data: any, scope: {[key: string]: any}, stack: any) => any\n}) => Run = bind2(cmd, 'run', false)\nexport const update: (data: {store: StateRef}) => Mov = ({store}) =>\n  mov({from: STACK, target: store})\n","import {StateRef} from './index.h'\nimport {nextStepID} from './id'\n\nexport const createStateRef = (current?: any): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current: any}) => current\n","export const callStackAReg = (stack: any, {fn}: any, {a}: any) => fn(stack, a)\nexport const callARegStack = (stack: any, {fn}: any, {a}: any) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: any, _: any) => fn(stack)\n","import {Node, StateRef} from './index.h'\n\nexport const getGraph = (graph: any): Node => graph.graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: any): StateRef => store.stateRef\nexport const getConfig = (opts: any) => opts.config\nexport const getNestedConfig = (opts: any) => opts.É”\nexport const getValue = (stack: any) => stack.value\nexport const getSubscribers = (store: any) => store.subscribers\nexport const getParent = (unit: any) => unit.parent\nexport const getForkPage = (val: any) => val.forkPage\n","import {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  for (let i = 0; i < links.length; i++) {\n    const link = getGraph(links[i])\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    getOwners(link).push(owner)\n    getLinks(owner).push(link)\n  }\n}\n","import {getConfig, getNestedConfig} from './getter'\nimport {assertObject} from './is'\n\nexport const onConfigNesting = (\n  rawConfig: any,\n  fn: (babelData: any, userConfig: any) => void,\n) => {\n  assertObject(rawConfig)\n  if (getNestedConfig(rawConfig)) {\n    fn(getConfig(rawConfig), getNestedConfig(rawConfig))\n  }\n}\n\nexport const processArgsToConfig = (args: any[]): [any[], any | void] => {\n  let metadata\n  onConfigNesting(args[0], (injected, config) => {\n    metadata = injected\n    args = config\n  })\n  return [args, metadata]\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-ignore\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && !targetNode.meta.sample) ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        currentNode.meta.op !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: any) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-ignore\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    //@ts-ignore\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import {Subscription, NodeUnit} from './index.h'\nimport {bind2} from './bind'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = bind2(clearNode, node, undefined)\n  result.unsubscribe = result\n  return result\n}\n","import {onConfigNesting} from './config'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit,\n  child: NodeUnit | NodeUnit[],\n  {\n    node,\n    scope,\n    meta,\n  }: {\n    node?: Array<Cmd | false | void | null>\n    scope?: {[name: string]: any}\n    meta?: {[name: string]: any}\n  },\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope,\n    meta,\n    family: {\n      owners: [parent, child],\n      links: child,\n    },\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  let config\n  onConfigNesting(opts, (injectedData, userConfig) => {\n    config = injectedData\n    opts = userConfig\n  })\n  const {from, to, meta = {op: 'forward'}} = opts\n  assertNodeSet(from, 'forward', '\"from\"')\n  assertNodeSet(to, 'forward', '\"to\"')\n  if (config) meta.config = config\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta,\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {step} from './typedef'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {throwError} from './throw'\nimport {isFunction} from './is'\nimport {forkPage} from './kernel'\nimport {getGraph} from './getter'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload: any) => any,\n): Subscription => {\n  if (!isFunction(handler)) throwError('.watch argument should be a function')\n  if (forkPage) {\n    const forkedNode = forkPage.nodeMap[getGraph(unit).id]\n    if (forkedNode) unit = forkedNode\n  }\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [step.run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {\n        owners: unit,\n      },\n      regional: true,\n    }),\n  )\n}\n","module.exports = require(\"../dist/no-ssr/index.js\");\n","import {Store, is, clearNode, createStore} from 'effector'\nimport React from 'react'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {throwError} from './throw'\n\nexport function useStore<State>(store: Store<State>): State {\n  if (!is.store(store)) throwError('expect useStore argument to be a store')\n\n  const currentValue = store.getState()\n  const inc = React.useReducer((n: any, action: void) => n + 1, 0)[1]\n  const currentStore = React.useRef({\n    store,\n    value: currentValue,\n    pending: false,\n  })\n  useIsomorphicLayoutEffect(() => {\n    const stop = store.updates.watch(upd => {\n      const ref = currentStore.current\n      if (!ref.pending) {\n        ref.value = upd\n        ref.pending = true\n        inc()\n        ref.pending = false\n      }\n    })\n    const newValue = store.getState()\n    const ref = currentStore.current\n    if (ref.store === store && ref.value !== newValue) {\n      ref.value = newValue\n      ref.pending = true\n      inc()\n      ref.pending = false\n    }\n    ref.store = store\n    return stop\n  }, [store])\n  return currentValue\n}\n\nexport function useStoreMap<State, Result, Keys extends ReadonlyArray<any>>(\n  configOrStore:\n    | {\n        store: Store<State>\n        keys: Keys\n        fn(state: State, keys: Keys): Result\n        updateFilter?: (update: Result, current: Result) => boolean\n      }\n    | Store<State>,\n  separateFn?: (state: State, keys: Keys) => Result,\n): Result {\n  let fn: (state: State, keys: Keys) => Result\n  let updateFilter: (update: Result, current: Result) => boolean\n  let store: Store<State>\n  let keys: Keys\n  if (separateFn) {\n    fn = separateFn\n    store = configOrStore as Store<State>\n    keys = ([] as unknown) as Keys\n  } else {\n    fn = (configOrStore as any).fn\n    store = (configOrStore as any).store\n    keys = (configOrStore as any).keys\n    updateFilter = (configOrStore as any).updateFilter\n  }\n  if (!is.store(store)) throwError('useStoreMap expects a store')\n  if (!Array.isArray(keys)) throwError('useStoreMap expects an array as keys')\n  if (typeof fn !== 'function') throwError('useStoreMap expects a function')\n  const result: Store<Result> = React.useMemo(\n    () =>\n      createStore(fn(store.getState(), keys), {updateFilter}).on(\n        store,\n        (_, state) => fn(state, keys),\n      ),\n    keys,\n  )\n  const state = useStore(result)\n  useIsomorphicLayoutEffect(\n    () => () => {\n      result.off(store)\n      clearNode(result, {deep: true})\n    },\n    keys,\n  )\n  return state\n}\n","export function withDisplayName(name: string, Component: any) {\n  Component.displayName = name\n  return Component\n}\n","import React from 'react'\nimport {Store, is, combine, createEvent} from 'effector'\nimport {useStore} from './useStore'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {StoreView} from './index.h'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\n\nexport function createComponent<Props, State>(\n  shape: Store<State> | {[key: string]: Store<any> | any},\n  renderProp: (props: Props, state: State) => React.ReactNode,\n): StoreView<State, Props> {\n  let store: Store<any>\n  if (is.store(shape)) {\n    store = shape\n  } else {\n    if (typeof shape === 'object' && shape !== null) {\n      store = combine(shape)\n    } else throwError('shape should be a store or object with stores')\n  }\n  let storeName = 'Unknown'\n  //@ts-ignore\n  if (store && store.shortName) {\n    storeName = store.shortName\n  }\n  const mounted = createEvent<any>()\n  const unmounted = createEvent<any>()\n\n  function RenderComponent(props: Props) {\n    const propsRef = React.useRef(props)\n    const state = useStore(store)\n    useIsomorphicLayoutEffect(() => {\n      mounted({props: propsRef.current, state: store.getState()})\n      return () => {\n        unmounted({props: propsRef.current, state: store.getState()})\n      }\n    }, [])\n    const result = renderProp(props, state)\n    propsRef.current = props\n    return result\n  }\n  RenderComponent.mounted = mounted\n  RenderComponent.unmounted = unmounted\n  return withDisplayName(`${storeName}.View`, RenderComponent)\n}\n","import {Store} from 'effector'\n\nimport {StoreConsumer} from './index.h'\nimport {createComponent} from './createComponent'\n\nexport function createStoreConsumer<State>(\n  store: Store<State>,\n): StoreConsumer<State> {\n  return createComponent(store, ({children}, state) => children(state))\n}\n","/* eslint-disable react-hooks/rules-of-hooks */\nimport React from 'react'\nimport {Store, is} from 'effector'\nimport {useStore, useStoreMap} from './useStore'\nimport {withDisplayName} from './withDisplayName'\nimport {throwError} from './throw'\n\nexport function useList<T>(\n  list: Store<T[]>,\n  renderItem:\n    | {\n        keys?: any[]\n        fn(item: T, index: number): React.ReactNode\n        getKey?: (item: T) => string\n      }\n    | ((item: T, index: number) => React.ReactNode),\n): React.ReactNode {\n  let keys = [] as any[]\n  let fn\n  let getKey: (item: T) => string\n  if (typeof renderItem === 'object' && renderItem !== null) {\n    if (renderItem.keys) keys = renderItem.keys\n    fn = renderItem.fn\n    if (renderItem.getKey) getKey = renderItem.getKey\n  } else {\n    fn = renderItem\n  }\n  if (!is.store(list)) throwError('expect useList first argument to be a store')\n  if (typeof fn !== 'function')\n    throwError(\"expect useList's renderItem to be a function\")\n  if (!Array.isArray(keys)) throwError(\"expect useList's keys to be an array\")\n  const Item = React.useMemo(() => {\n    const Item = withDisplayName(\n      `${list.shortName || 'Unknown'}.Item`,\n      (\n        props:\n          | {index: number; keys: any[]; keyVal: never; value: never}\n          | {index: never; keys: any[]; keyVal: string; value: T},\n      ) => {\n        const {index, keys, keyVal, value} = props\n        const isKeyed = !!fnRef.current[1]\n        if (isKeyed) {\n          return fnRef.current[0](value, keyVal as any)\n        }\n        const item = useStoreMap({\n          store: list,\n          keys: [index, ...keys],\n          fn: (list, keys) => list[keys[0]],\n        })\n        return fnRef.current[0](item, index)\n      },\n    )\n    return React.memo(Item)\n  }, [list, !!getKey!])\n  const fnRef = React.useRef([fn, getKey!] as const)\n  fnRef.current = [fn, getKey!]\n  const keysSelfMemo = React.useMemo(() => keys, keys)\n  if (getKey!) {\n    return useStore(list).map(value => {\n      const key = fnRef.current[1](value)\n      return React.createElement(Item, {\n        keyVal: key,\n        key,\n        keys: keysSelfMemo,\n        value,\n      })\n    })\n  } else {\n    const length = useStoreMap({\n      store: list,\n      keys: [list],\n      fn: list => list.length,\n    })\n    return Array.from({length}, (_, i) =>\n      React.createElement(Item, {\n        index: i,\n        key: i,\n        keys: keysSelfMemo,\n      }),\n    )\n  }\n}\n","import React from 'react'\nimport {Store} from 'effector'\n\nimport {useStore} from './useStore'\nimport {withDisplayName} from './withDisplayName'\n\nexport function createReactState<State>(\n  store: Store<State>,\n  Component: React.ComponentType<any>,\n) {\n  const wrappedComponentName =\n    Component.displayName || Component.name || 'Unknown'\n  return withDisplayName(`Connect(${wrappedComponentName})`, (props: any) =>\n    React.createElement(Component, Object.assign({}, props, useStore(store))),\n  )\n}\n","import React from 'react'\nimport {createStore, launch, Store, Domain, createEvent} from 'effector'\nimport {Gate} from './index.h'\nimport {useIsomorphicLayoutEffect} from './useIsomorphicLayoutEffect'\nimport {withDisplayName} from './withDisplayName'\n\nexport function useGate<Props>(\n  GateComponent: Gate<Props>,\n  props: Props = {} as any,\n) {\n  const propsRef = React.useRef<any>(null)\n  useIsomorphicLayoutEffect(() => {\n    GateComponent.open(propsRef.current)\n    return () => GateComponent.close(propsRef.current) as any\n  }, [GateComponent])\n  if (!shallowCompare(propsRef.current, props)) {\n    propsRef.current = props\n    GateComponent.set(props)\n  }\n}\n\nfunction shallowCompare(a: any, b: any) {\n  if (a === b) return true\n  if (\n    typeof a === 'object' &&\n    a !== null &&\n    typeof b === 'object' &&\n    b !== null\n  ) {\n    const aKeys = Object.keys(a)\n    const bKeys = Object.keys(b)\n    if (aKeys.length !== bKeys.length) return false\n    for (let i = 0; i < aKeys.length; i++) {\n      const key = aKeys[i]\n      if (a[key] !== b[key]) return false\n    }\n    return true\n  }\n  return false\n}\nexport function createGateImplementation<State>({\n  name = 'gate',\n  domain,\n  defaultState,\n  hook: useGateHook,\n}: {\n  name?: string\n  domain?: Domain\n  defaultState: State | {}\n  hook: typeof useGate\n}): Gate<State> {\n  const fullName = `${domain ? `${domain.compositeName.fullName}/` : ''}${name}`\n  const set = createEvent<State>(`${fullName}.set`)\n  const open = createEvent<State>(`${fullName}.open`)\n  const close = createEvent<State>(`${fullName}.close`)\n  const status = createStore(Boolean(false), {\n    name: `${fullName}.status`,\n  })\n    .on(open, () => Boolean(true))\n    .on(close, () => Boolean(false))\n  const state = createStore(defaultState as State, {\n    name: `${fullName}.state`,\n  })\n    .on(set, (_, state) => state)\n    .reset(close)\n  if (domain) {\n    const {hooks} = domain as any\n    launch({\n      target: [\n        hooks.store,\n        hooks.store,\n        hooks.event,\n        hooks.event,\n        hooks.event,\n      ] as any,\n      params: [status, state, open, close, set],\n    })\n  }\n  function GateComponent(props: State) {\n    useGateHook(GateComponent as any, props)\n    return null\n  }\n  GateComponent.open = open\n  GateComponent.close = close\n  GateComponent.status = status\n  GateComponent.state = state\n  GateComponent.set = set\n  return withDisplayName(`Gate:${fullName}`, GateComponent)\n}\nexport function createGate<Props>(\n  name: string = 'gate',\n  defaultState: Props = {} as any,\n): Gate<Props> {\n  let domain\n  if (typeof name === 'object' && name !== null) {\n    if ('defaultState' in name) {\n      //@ts-ignore\n      defaultState = name.defaultState\n    }\n    //@ts-ignore\n    if (name.domain) domain = name.domain\n    //@ts-ignore\n    name = name.name\n  }\n  return createGateImplementation({\n    name,\n    domain,\n    defaultState,\n    hook: useGate,\n  })\n}\n","import {Event} from 'effector'\n\n/**\nbind event to scope\n\nworks like React.useCallback, but for scopes\n*/\nexport function useEvent<T>(event: Event<T>): (payload: T) => T {\n  return event\n}\n","import React from 'react'\n\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n","export const throwError = (message: string) => {\n  throw Error(message)\n}\n","import React from 'react'\nimport {Store} from 'effector'\nimport {useStore} from './useStore'\nimport {withDisplayName} from './withDisplayName'\n\nexport const createContextComponent = <Props, State, Context>(\n  store: Store<State>,\n  context: React.Context<Context>,\n  renderProp: (props: Props, state: State, context: Context) => React.ReactNode,\n): React.ComponentType<Props> =>\n  withDisplayName(\n    `${store.shortName || 'Unknown'}.ContextComponent`,\n    (props: any) => {\n      const ctx = React.useContext(context)\n      const state = useStore(store)\n      return renderProp(props, state, ctx)\n    },\n  )\n","import React from 'react'\n\nimport {Store, is} from 'effector'\nimport {createReactState} from './createReactState'\n\nexport const connect = <State>(Component: React.ComponentType<any>) => (\n  store: Store<State>,\n) => {\n  let View: any = Component\n  if (typeof Component !== 'function') {\n    View = store\n    store = Component as any\n  }\n  return createReactState(store, View)\n}\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\nvar enhanceError = require('./core/enhanceError');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  }\n};\n\ndefaults.headers = {\n  common: {\n    'Accept': 'application/json, text/plain, */*'\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","module.exports = require('./lib/axios');","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(resolve, reject, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken) {\n      // Handle cancellation\n      config.cancelToken.promise.then(function onCanceled(cancel) {\n        if (!request) {\n          return;\n        }\n\n        request.abort();\n        reject(cancel);\n        // Clean up request\n        request = null;\n      });\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  var valueFromConfig2Keys = ['url', 'method', 'data'];\n  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];\n  var defaultToConfig2Keys = [\n    'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',\n    'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',\n    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',\n    'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',\n    'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'\n  ];\n  var directMergeKeys = ['validateStatus'];\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    }\n  });\n\n  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);\n\n  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      config[prop] = getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  utils.forEach(directMergeKeys, function merge(prop) {\n    if (prop in config2) {\n      config[prop] = getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      config[prop] = getMergedValue(undefined, config1[prop]);\n    }\n  });\n\n  var axiosKeys = valueFromConfig2Keys\n    .concat(mergeDeepPropertiesKeys)\n    .concat(defaultToConfig2Keys)\n    .concat(directMergeKeys);\n\n  var otherKeys = Object\n    .keys(config1)\n    .concat(Object.keys(config2))\n    .filter(function filterAxiosKeys(key) {\n      return axiosKeys.indexOf(key) === -1;\n    });\n\n  utils.forEach(otherKeys, mergeDeepProperties);\n\n  return config;\n};\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\n/**\n * Helpers to enable Immutable compatibility *without* bringing in\n * the 'immutable' package as a dependency.\n */\n\n/**\n * Check if an object is immutable by checking if it has a key specific\n * to the immutable library.\n *\n * @param  {any} object\n * @return {bool}\n */\nfunction isImmutable(object) {\n  return !!(object && typeof object.hasOwnProperty === 'function' && (object.hasOwnProperty('__ownerID') || // Immutable.Map\n  object._map && object._map.hasOwnProperty('__ownerID'))); // Immutable.Record\n}\n/**\n * Denormalize an immutable entity.\n *\n * @param  {Schema} schema\n * @param  {Immutable.Map|Immutable.Record} input\n * @param  {function} unvisit\n * @param  {function} getDenormalizedEntity\n * @return {Immutable.Map|Immutable.Record}\n */\n\nfunction denormalizeImmutable(schema, input, unvisit) {\n  return Object.keys(schema).reduce(function (object, key) {\n    // Immutable maps cast keys to strings on write so we need to ensure\n    // we're accessing them using string keys.\n    var stringKey = \"\" + key;\n\n    if (object.has(stringKey)) {\n      return object.set(stringKey, unvisit(object.get(stringKey), schema[stringKey]));\n    } else {\n      return object;\n    }\n  }, input);\n}\n\nvar getDefaultGetId = function getDefaultGetId(idAttribute) {\n  return function (input) {\n    return isImmutable(input) ? input.get(idAttribute) : input[idAttribute];\n  };\n};\n\nvar EntitySchema = /*#__PURE__*/function () {\n  function EntitySchema(key, definition, options) {\n    if (definition === void 0) {\n      definition = {};\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!key || typeof key !== 'string') {\n      throw new Error(\"Expected a string key for Entity, but found \" + key + \".\");\n    }\n\n    var _options = options,\n        _options$idAttribute = _options.idAttribute,\n        idAttribute = _options$idAttribute === void 0 ? 'id' : _options$idAttribute,\n        _options$mergeStrateg = _options.mergeStrategy,\n        mergeStrategy = _options$mergeStrateg === void 0 ? function (entityA, entityB) {\n      return _extends({}, entityA, entityB);\n    } : _options$mergeStrateg,\n        _options$processStrat = _options.processStrategy,\n        processStrategy = _options$processStrat === void 0 ? function (input) {\n      return _extends({}, input);\n    } : _options$processStrat,\n        _options$fallbackStra = _options.fallbackStrategy,\n        fallbackStrategy = _options$fallbackStra === void 0 ? function (key, schema) {\n      return undefined;\n    } : _options$fallbackStra;\n    this._key = key;\n    this._getId = typeof idAttribute === 'function' ? idAttribute : getDefaultGetId(idAttribute);\n    this._idAttribute = idAttribute;\n    this._mergeStrategy = mergeStrategy;\n    this._processStrategy = processStrategy;\n    this._fallbackStrategy = fallbackStrategy;\n    this.define(definition);\n  }\n\n  var _proto = EntitySchema.prototype;\n\n  _proto.define = function define(definition) {\n    this.schema = Object.keys(definition).reduce(function (entitySchema, key) {\n      var _extends2;\n\n      var schema = definition[key];\n      return _extends({}, entitySchema, (_extends2 = {}, _extends2[key] = schema, _extends2));\n    }, this.schema || {});\n  };\n\n  _proto.getId = function getId(input, parent, key) {\n    return this._getId(input, parent, key);\n  };\n\n  _proto.merge = function merge(entityA, entityB) {\n    return this._mergeStrategy(entityA, entityB);\n  };\n\n  _proto.fallback = function fallback(id, schema) {\n    return this._fallbackStrategy(id, schema);\n  };\n\n  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    var _this = this;\n\n    var id = this.getId(input, parent, key);\n    var entityType = this.key;\n\n    if (!(entityType in visitedEntities)) {\n      visitedEntities[entityType] = {};\n    }\n\n    if (!(id in visitedEntities[entityType])) {\n      visitedEntities[entityType][id] = [];\n    }\n\n    if (visitedEntities[entityType][id].some(function (entity) {\n      return entity === input;\n    })) {\n      return id;\n    }\n\n    visitedEntities[entityType][id].push(input);\n\n    var processedEntity = this._processStrategy(input, parent, key);\n\n    Object.keys(this.schema).forEach(function (key) {\n      if (processedEntity.hasOwnProperty(key) && typeof processedEntity[key] === 'object') {\n        var schema = _this.schema[key];\n        var resolvedSchema = typeof schema === 'function' ? schema(input) : schema;\n        processedEntity[key] = visit(processedEntity[key], processedEntity, key, resolvedSchema, addEntity, visitedEntities);\n      }\n    });\n    addEntity(this, processedEntity, input, parent, key);\n    return id;\n  };\n\n  _proto.denormalize = function denormalize(entity, unvisit) {\n    var _this2 = this;\n\n    if (isImmutable(entity)) {\n      return denormalizeImmutable(this.schema, entity, unvisit);\n    }\n\n    Object.keys(this.schema).forEach(function (key) {\n      if (entity.hasOwnProperty(key)) {\n        var schema = _this2.schema[key];\n        entity[key] = unvisit(entity[key], schema);\n      }\n    });\n    return entity;\n  };\n\n  _createClass(EntitySchema, [{\n    key: \"key\",\n    get: function get() {\n      return this._key;\n    }\n  }, {\n    key: \"idAttribute\",\n    get: function get() {\n      return this._idAttribute;\n    }\n  }]);\n\n  return EntitySchema;\n}();\n\nvar PolymorphicSchema = /*#__PURE__*/function () {\n  function PolymorphicSchema(definition, schemaAttribute) {\n    if (schemaAttribute) {\n      this._schemaAttribute = typeof schemaAttribute === 'string' ? function (input) {\n        return input[schemaAttribute];\n      } : schemaAttribute;\n    }\n\n    this.define(definition);\n  }\n\n  var _proto = PolymorphicSchema.prototype;\n\n  _proto.define = function define(definition) {\n    this.schema = definition;\n  };\n\n  _proto.getSchemaAttribute = function getSchemaAttribute(input, parent, key) {\n    return !this.isSingleSchema && this._schemaAttribute(input, parent, key);\n  };\n\n  _proto.inferSchema = function inferSchema(input, parent, key) {\n    if (this.isSingleSchema) {\n      return this.schema;\n    }\n\n    var attr = this.getSchemaAttribute(input, parent, key);\n    return this.schema[attr];\n  };\n\n  _proto.normalizeValue = function normalizeValue(value, parent, key, visit, addEntity, visitedEntities) {\n    var schema = this.inferSchema(value, parent, key);\n\n    if (!schema) {\n      return value;\n    }\n\n    var normalizedValue = visit(value, parent, key, schema, addEntity, visitedEntities);\n    return this.isSingleSchema || normalizedValue === undefined || normalizedValue === null ? normalizedValue : {\n      id: normalizedValue,\n      schema: this.getSchemaAttribute(value, parent, key)\n    };\n  };\n\n  _proto.denormalizeValue = function denormalizeValue(value, unvisit) {\n    var schemaKey = isImmutable(value) ? value.get('schema') : value.schema;\n\n    if (!this.isSingleSchema && !schemaKey) {\n      return value;\n    }\n\n    var id = this.isSingleSchema ? undefined : isImmutable(value) ? value.get('id') : value.id;\n    var schema = this.isSingleSchema ? this.schema : this.schema[schemaKey];\n    return unvisit(id || value, schema);\n  };\n\n  _createClass(PolymorphicSchema, [{\n    key: \"isSingleSchema\",\n    get: function get() {\n      return !this._schemaAttribute;\n    }\n  }]);\n\n  return PolymorphicSchema;\n}();\n\nvar UnionSchema = /*#__PURE__*/function (_PolymorphicSchema) {\n  _inheritsLoose(UnionSchema, _PolymorphicSchema);\n\n  function UnionSchema(definition, schemaAttribute) {\n    if (!schemaAttribute) {\n      throw new Error('Expected option \"schemaAttribute\" not found on UnionSchema.');\n    }\n\n    return _PolymorphicSchema.call(this, definition, schemaAttribute) || this;\n  }\n\n  var _proto = UnionSchema.prototype;\n\n  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    return this.normalizeValue(input, parent, key, visit, addEntity, visitedEntities);\n  };\n\n  _proto.denormalize = function denormalize(input, unvisit) {\n    return this.denormalizeValue(input, unvisit);\n  };\n\n  return UnionSchema;\n}(PolymorphicSchema);\n\nvar ValuesSchema = /*#__PURE__*/function (_PolymorphicSchema) {\n  _inheritsLoose(ValuesSchema, _PolymorphicSchema);\n\n  function ValuesSchema() {\n    return _PolymorphicSchema.apply(this, arguments) || this;\n  }\n\n  var _proto = ValuesSchema.prototype;\n\n  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    var _this = this;\n\n    return Object.keys(input).reduce(function (output, key, index) {\n      var _extends2;\n\n      var value = input[key];\n      return value !== undefined && value !== null ? _extends({}, output, (_extends2 = {}, _extends2[key] = _this.normalizeValue(value, input, key, visit, addEntity, visitedEntities), _extends2)) : output;\n    }, {});\n  };\n\n  _proto.denormalize = function denormalize(input, unvisit) {\n    var _this2 = this;\n\n    return Object.keys(input).reduce(function (output, key) {\n      var _extends3;\n\n      var entityOrId = input[key];\n      return _extends({}, output, (_extends3 = {}, _extends3[key] = _this2.denormalizeValue(entityOrId, unvisit), _extends3));\n    }, {});\n  };\n\n  return ValuesSchema;\n}(PolymorphicSchema);\n\nvar validateSchema = function validateSchema(definition) {\n  var isArray = Array.isArray(definition);\n\n  if (isArray && definition.length > 1) {\n    throw new Error(\"Expected schema definition to be a single schema, but found \" + definition.length + \".\");\n  }\n\n  return definition[0];\n};\n\nvar getValues = function getValues(input) {\n  return Array.isArray(input) ? input : Object.keys(input).map(function (key) {\n    return input[key];\n  });\n};\n\nvar normalize = function normalize(schema, input, parent, key, visit, addEntity, visitedEntities) {\n  schema = validateSchema(schema);\n  var values = getValues(input); // Special case: Arrays pass *their* parent on to their children, since there\n  // is not any special information that can be gathered from themselves directly\n\n  return values.map(function (value, index) {\n    return visit(value, parent, key, schema, addEntity, visitedEntities);\n  });\n};\nvar denormalize = function denormalize(schema, input, unvisit) {\n  schema = validateSchema(schema);\n  return input && input.map ? input.map(function (entityOrId) {\n    return unvisit(entityOrId, schema);\n  }) : input;\n};\n\nvar ArraySchema = /*#__PURE__*/function (_PolymorphicSchema) {\n  _inheritsLoose(ArraySchema, _PolymorphicSchema);\n\n  function ArraySchema() {\n    return _PolymorphicSchema.apply(this, arguments) || this;\n  }\n\n  var _proto = ArraySchema.prototype;\n\n  _proto.normalize = function normalize(input, parent, key, visit, addEntity, visitedEntities) {\n    var _this = this;\n\n    var values = getValues(input);\n    return values.map(function (value, index) {\n      return _this.normalizeValue(value, parent, key, visit, addEntity, visitedEntities);\n    }).filter(function (value) {\n      return value !== undefined && value !== null;\n    });\n  };\n\n  _proto.denormalize = function denormalize(input, unvisit) {\n    var _this2 = this;\n\n    return input && input.map ? input.map(function (value) {\n      return _this2.denormalizeValue(value, unvisit);\n    }) : input;\n  };\n\n  return ArraySchema;\n}(PolymorphicSchema);\n\nvar _normalize = function normalize(schema, input, parent, key, visit, addEntity, visitedEntities) {\n  var object = _extends({}, input);\n\n  Object.keys(schema).forEach(function (key) {\n    var localSchema = schema[key];\n    var resolvedLocalSchema = typeof localSchema === 'function' ? localSchema(input) : localSchema;\n    var value = visit(input[key], input, key, resolvedLocalSchema, addEntity, visitedEntities);\n\n    if (value === undefined || value === null) {\n      delete object[key];\n    } else {\n      object[key] = value;\n    }\n  });\n  return object;\n};\n\nvar _denormalize = function denormalize(schema, input, unvisit) {\n  if (isImmutable(input)) {\n    return denormalizeImmutable(schema, input, unvisit);\n  }\n\n  var object = _extends({}, input);\n\n  Object.keys(schema).forEach(function (key) {\n    if (object[key] != null) {\n      object[key] = unvisit(object[key], schema[key]);\n    }\n  });\n  return object;\n};\n\nvar ObjectSchema = /*#__PURE__*/function () {\n  function ObjectSchema(definition) {\n    this.define(definition);\n  }\n\n  var _proto = ObjectSchema.prototype;\n\n  _proto.define = function define(definition) {\n    this.schema = Object.keys(definition).reduce(function (entitySchema, key) {\n      var _extends2;\n\n      var schema = definition[key];\n      return _extends({}, entitySchema, (_extends2 = {}, _extends2[key] = schema, _extends2));\n    }, this.schema || {});\n  };\n\n  _proto.normalize = function normalize() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _normalize.apply(void 0, [this.schema].concat(args));\n  };\n\n  _proto.denormalize = function denormalize() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return _denormalize.apply(void 0, [this.schema].concat(args));\n  };\n\n  return ObjectSchema;\n}();\n\nvar visit = function visit(value, parent, key, schema, addEntity, visitedEntities) {\n  if (typeof value !== 'object' || !value) {\n    return value;\n  }\n\n  if (typeof schema === 'object' && (!schema.normalize || typeof schema.normalize !== 'function')) {\n    var method = Array.isArray(schema) ? normalize : _normalize;\n    return method(schema, value, parent, key, visit, addEntity, visitedEntities);\n  }\n\n  return schema.normalize(value, parent, key, visit, addEntity, visitedEntities);\n};\n\nvar addEntities = function addEntities(entities) {\n  return function (schema, processedEntity, value, parent, key) {\n    var schemaKey = schema.key;\n    var id = schema.getId(value, parent, key);\n\n    if (!(schemaKey in entities)) {\n      entities[schemaKey] = {};\n    }\n\n    var existingEntity = entities[schemaKey][id];\n\n    if (existingEntity) {\n      entities[schemaKey][id] = schema.merge(existingEntity, processedEntity);\n    } else {\n      entities[schemaKey][id] = processedEntity;\n    }\n  };\n};\n\nvar schema = {\n  Array: ArraySchema,\n  Entity: EntitySchema,\n  Object: ObjectSchema,\n  Union: UnionSchema,\n  Values: ValuesSchema\n};\nvar normalize$1 = function normalize(input, schema) {\n  if (!input || typeof input !== 'object') {\n    throw new Error(\"Unexpected input given to normalize. Expected type to be \\\"object\\\", found \\\"\" + (input === null ? 'null' : typeof input) + \"\\\".\");\n  }\n\n  var entities = {};\n  var addEntity = addEntities(entities);\n  var visitedEntities = {};\n  var result = visit(input, input, null, schema, addEntity, visitedEntities);\n  return {\n    entities: entities,\n    result: result\n  };\n};\n\nvar unvisitEntity = function unvisitEntity(id, schema, unvisit, getEntity, cache) {\n  var entity = getEntity(id, schema);\n\n  if (entity === undefined && schema instanceof EntitySchema) {\n    entity = schema.fallback(id, schema);\n  }\n\n  if (typeof entity !== 'object' || entity === null) {\n    return entity;\n  }\n\n  if (!cache[schema.key]) {\n    cache[schema.key] = {};\n  }\n\n  if (!cache[schema.key][id]) {\n    // Ensure we don't mutate it non-immutable objects\n    var entityCopy = isImmutable(entity) ? entity : _extends({}, entity); // Need to set this first so that if it is referenced further within the\n    // denormalization the reference will already exist.\n\n    cache[schema.key][id] = entityCopy;\n    cache[schema.key][id] = schema.denormalize(entityCopy, unvisit);\n  }\n\n  return cache[schema.key][id];\n};\n\nvar getUnvisit = function getUnvisit(entities) {\n  var cache = {};\n  var getEntity = getEntities(entities);\n  return function unvisit(input, schema) {\n    if (typeof schema === 'object' && (!schema.denormalize || typeof schema.denormalize !== 'function')) {\n      var method = Array.isArray(schema) ? denormalize : _denormalize;\n      return method(schema, input, unvisit);\n    }\n\n    if (input === undefined || input === null) {\n      return input;\n    }\n\n    if (schema instanceof EntitySchema) {\n      return unvisitEntity(input, schema, unvisit, getEntity, cache);\n    }\n\n    return schema.denormalize(input, unvisit);\n  };\n};\n\nvar getEntities = function getEntities(entities) {\n  var isImmutable$1 = isImmutable(entities);\n  return function (entityOrId, schema) {\n    var schemaKey = schema.key;\n\n    if (typeof entityOrId === 'object') {\n      return entityOrId;\n    }\n\n    if (isImmutable$1) {\n      return entities.getIn([schemaKey, entityOrId.toString()]);\n    }\n\n    return entities[schemaKey] && entities[schemaKey][entityOrId];\n  };\n};\n\nvar denormalize$1 = function denormalize(input, schema, entities) {\n  if (typeof input !== 'undefined') {\n    return getUnvisit(entities)(input, schema);\n  }\n};\n\nexport { denormalize$1 as denormalize, normalize$1 as normalize, schema };\n","const errors = {\n\t0: \"Illegal state\",\n\t1: \"Immer drafts cannot have computed properties\",\n\t2: \"This object has been frozen and should not be mutated\",\n\t3(data: any) {\n\t\treturn (\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\tdata\n\t\t)\n\t},\n\t4: \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t5: \"Immer forbids circular references\",\n\t6: \"The first or second argument to `produce` must be a function\",\n\t7: \"The third argument to `produce` must be a function or undefined\",\n\t8: \"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t9: \"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t10: \"The given draft is already finalized\",\n\t11: \"Object.defineProperty() cannot be used on an Immer draft\",\n\t12: \"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t13: \"Immer only supports deleting array indices\",\n\t14: \"Immer only supports setting array indices and the 'length' property\",\n\t15(path: string) {\n\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t},\n\t16: 'Sets cannot have \"replace\" patches.',\n\t17(op: string) {\n\t\treturn \"Unsupported patch operation: \" + op\n\t},\n\t18(plugin: string) {\n\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t},\n\t20: \"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",\n\t21(thing: string) {\n\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t},\n\t22(thing: string) {\n\t\treturn `'current' expects a draft, got: ${thing}`\n\t},\n\t23(thing: string) {\n\t\treturn `'original' expects a draft, got: ${thing}`\n\t},\n\t24: \"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n} as const\n\nexport function die(error: keyof typeof errors, ...args: any[]): never {\n\tif (__DEV__) {\n\t\tconst e = errors[error]\n\t\tconst msg = !e\n\t\t\t? \"unknown error nr: \" + error\n\t\t\t: typeof e === \"function\"\n\t\t\t? e.apply(null, args as any)\n\t\t\t: e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}${\n\t\t\targs.length ? \" \" + args.map(s => `'${s}'`).join(\",\") : \"\"\n\t\t}. Find the full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\thasMap,\n\tArchtypeObject,\n\tArchtypeArray,\n\tArchtypeMap,\n\tArchtypeSet,\n\tdie\n} from \"../internal\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(23, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/*#__PURE__*/\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport const getOwnPropertyDescriptors =\n\tObject.getOwnPropertyDescriptors ||\n\tfunction getOwnPropertyDescriptors(target: any) {\n\t\t// Polyfill needed for Hermes and IE, see https://github.com/facebook/hermes/issues/274\n\t\tconst res: any = {}\n\t\townKeys(target).forEach(key => {\n\t\t\tres[key] = Object.getOwnPropertyDescriptor(target, key)\n\t\t})\n\t\treturn res\n\t}\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tenumerableOnly?: boolean\n): void\nexport function each(obj: any, iter: any, enumerableOnly = false) {\n\tif (getArchtype(obj) === ArchtypeObject) {\n\t\t;(enumerableOnly ? Object.keys : ownKeys)(obj).forEach(key => {\n\t\t\tif (!enumerableOnly || typeof key !== \"symbol\") iter(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): 0 | 1 | 2 | 3 {\n\t/* istanbul ignore next */\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_ > 3\n\t\t\t? state.type_ - 4 // cause Object and Array map back from 4 and 5\n\t\t\t: (state.type_ as any) // others are the same\n\t\t: Array.isArray(thing)\n\t\t? ArchtypeArray\n\t\t: isMap(thing)\n\t\t? ArchtypeMap\n\t\t: isSet(thing)\n\t\t? ArchtypeSet\n\t\t: ArchtypeObject\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchtypeMap\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchtypeMap ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchtypeMap) thing.set(propOrOldValue, value)\n\telse if (t === ArchtypeSet) {\n\t\tthing.delete(propOrOldValue)\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any) {\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\tconst descriptors = getOwnPropertyDescriptors(base)\n\tdelete descriptors[DRAFT_STATE as any]\n\tlet keys = ownKeys(descriptors)\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tconst key: any = keys[i]\n\t\tconst desc = descriptors[key]\n\t\tif (desc.writable === false) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable = true\n\t\t}\n\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t// with libraries that trap values, like mobx or vue\n\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\tif (desc.get || desc.set)\n\t\t\tdescriptors[key] = {\n\t\t\t\tconfigurable: true,\n\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\tvalue: base[key]\n\t\t\t}\n\t}\n\treturn Object.create(Object.getPrototypeOf(base), descriptors)\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tobj.set = obj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (key, value) => freeze(value, true), true)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\tif (obj == null || typeof obj !== \"object\") return true\n\t// See #600, IE dies on non-objects in Object.isFrozen\n\treturn Object.isFrozen(obj)\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"../internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\n\nexport const ArchtypeObject = 0\nexport const ArchtypeArray = 1\nexport const ArchtypeMap = 2\nexport const ArchtypeSet = 3\n\nexport const ProxyTypeProxyObject = 0\nexport const ProxyTypeProxyArray = 1\nexport const ProxyTypeES5Object = 4\nexport const ProxyTypeES5Array = 5\nexport const ProxyTypeMap = 2\nexport const ProxyTypeSet = 3\n\nexport interface ImmerBaseState {\n\tparent_?: ImmerState\n\tscope_: ImmerScope\n\tmodified_: boolean\n\tfinalized_: boolean\n\tisManual_: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tImmerState,\n\tPatch,\n\tImmerScope,\n\tDrafted,\n\tAnyObject,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tProxyTypeES5Array,\n\tProxyTypeES5Object,\n\tProxyTypeMap,\n\tProxyTypeSet,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\trootState: ImmerState,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: Patch[]): T\n\t}\n\tES5?: {\n\t\twillFinalizeES5_(scope: ImmerScope, result: any, isReplaced: boolean): void\n\t\tcreateES5Proxy_<T>(\n\t\t\tbase: T,\n\t\t\tparent?: ImmerState\n\t\t): Drafted<T, ES5ObjectState | ES5ArrayState>\n\t\thasChanges_(state: ES5ArrayState | ES5ObjectState): boolean\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(18, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n\n/** ES5 Plugin */\n\ninterface ES5BaseState extends ImmerBaseState {\n\tassigned_: {[key: string]: any}\n\tparent_?: ImmerState\n\trevoked_: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Object\n\tdraft_: Drafted<AnyObject, ES5ObjectState>\n\tbase_: AnyObject\n\tcopy_: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype_: typeof ProxyTypeES5Array\n\tdraft_: Drafted<AnyObject, ES5ArrayState>\n\tbase_: any\n\tcopy_: any\n}\n\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeMap\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: typeof ProxyTypeSet\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray,\n\tgetPlugin\n} from \"../internal\"\nimport {die} from \"../utils/errors\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\tif (__DEV__ && !currentScope) die(0)\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type_ === ProxyTypeProxyObject ||\n\t\tstate.type_ === ProxyTypeProxyArray\n\t)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tProxyTypeES5Object,\n\tProxyTypeES5Array,\n\tProxyTypeSet,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tshallowCopy\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (!scope.immer_.useProxies_)\n\t\tgetPlugin(\"ES5\").willFinalizeES5_(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE],\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(\n\t\t\tvalue,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path),\n\t\t\ttrue // See #590, don't recurse into non-enumarable of non drafted objects\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result =\n\t\t\t// For ES5, create a good copy from the draft first, with added keys and without deleted keys.\n\t\t\tstate.type_ === ProxyTypeES5Object || state.type_ === ProxyTypeES5Array\n\t\t\t\t? (state.copy_ = shallowCopy(state.draft_))\n\t\t\t\t: state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// Although the original test case doesn't seem valid anyway, so if this in the way we can turn the next line\n\t\t// back to each(result, ....)\n\t\teach(\n\t\t\tstate.type_ === ProxyTypeSet ? new Set(result) : result,\n\t\t\t(key, childValue) =>\n\t\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (__DEV__ && childValue === targetObject) die(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ProxyTypeSet && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\tif (!parentState || !parentState.scope_.parent_)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\tif (scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tProxyTypeProxyObject,\n\tProxyTypeProxyArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyObject\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: typeof ProxyTypeProxyArray\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ProxyTypeProxyArray : (ProxyTypeProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(\n\t\t\t\tstate.scope_.immer_,\n\t\t\t\tvalue,\n\t\t\t\tstate\n\t\t\t))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existig to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (state.copy_![prop] === value && typeof value !== \"number\") return true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy_) delete state.copy_[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ProxyTypeProxyArray || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (__DEV__ && isNaN(parseInt(prop as any))) die(13)\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (__DEV__ && prop !== \"length\" && isNaN(parseInt(prop as any))) die(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = Object.getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = Object.getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {base_: any; copy_: any}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(state.base_)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\thasProxies,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies_: boolean = hasProxies\n\n\tautoFreeze_: boolean = true\n\n\tconstructor(config?: {useProxies?: boolean; autoFreeze?: boolean}) {\n\t\tif (typeof config?.useProxies === \"boolean\")\n\t\t\tthis.setUseProxies(config!.useProxies)\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(this, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\t\t\t\treturn processResult(result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\trevokeScope(scope)\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\treturn result\n\t\t} else die(21, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (\n\t\targ1: any,\n\t\targ2?: any,\n\t\targ3?: any\n\t): any => {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(this, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (__DEV__) {\n\t\t\tif (!state || !state.isManual_) die(9)\n\t\t\tif (state.finalized_) die(10)\n\t\t}\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tif (value && !hasProxies) {\n\t\t\tdie(20)\n\t\t}\n\t\tthis.useProxies_ = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches.slice(i + 1))\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\timmer: Immer,\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: immer.useProxies_\n\t\t? createProxyProxy(value, parent)\n\t\t: getPlugin(\"ES5\").createES5Proxy_(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tget,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tArchtypeMap,\n\tArchtypeSet,\n\tgetArchtype,\n\tgetPlugin\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(22, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tconst archType = getArchtype(value)\n\tif (state) {\n\t\tif (\n\t\t\t!state.modified_ &&\n\t\t\t(state.type_ < 4 || !getPlugin(\"ES5\").hasChanges_(state as any))\n\t\t)\n\t\t\treturn state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = copyHelper(value, archType)\n\t\tstate.finalized_ = false\n\t} else {\n\t\tcopy = copyHelper(value, archType)\n\t}\n\n\teach(copy, (key, childValue) => {\n\t\tif (state && get(state.base_, key) === childValue) return // no need to copy or search in something that didn't change\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\t// In the future, we might consider freezing here, based on the current settings\n\treturn archType === ArchtypeSet ? new Set(copy) : copy\n}\n\nfunction copyHelper(value: any, archType: number): any {\n\t// creates a shallow copy, even if it is a map or set\n\tswitch (archType) {\n\t\tcase ArchtypeMap:\n\t\t\treturn new Map(value)\n\t\tcase ArchtypeSet:\n\t\t\t// Set will be cloned as array temporarily, so that we can replace individual items\n\t\t\treturn Array.from(value)\n\t}\n\treturn shallowCopy(value)\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enableES5} from \"./plugins/es5\"\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\nexport {enableAllPlugins} from \"./plugins/all\"\n","// Should be no imports here!\n\n// Some things that should be evaluated before all else...\n\n// We only want to know if non-polyfilled symbols are available\nconst hasSymbol =\n\ttypeof Symbol !== \"undefined\" && typeof Symbol(\"x\") === \"symbol\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\nexport const hasProxies =\n\ttypeof Proxy !== \"undefined\" &&\n\ttypeof Proxy.revocable !== \"undefined\" &&\n\ttypeof Reflect !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol.for(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol.for(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\n// Even a polyfilled Symbol might provide Symbol.iterator\nexport const iteratorSymbol: typeof Symbol.iterator =\n\t(typeof Symbol != \"undefined\" && Symbol.iterator) || (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar context = require('effector-react');\nrequire('react');\nrequire('effector');\nvar list$1 = require('../list-98ebb739.js');\n\nfunction _interopNamespace(e) {\n\tif (e && e.__esModule) return e;\n\tvar n = Object.create(null);\n\tif (e) {\n\t\tObject.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default') {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () {\n\t\t\t\t\t\treturn e[k];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\tn['default'] = e;\n\treturn Object.freeze(n);\n}\n\nvar context__namespace = /*#__PURE__*/_interopNamespace(context);\n\nvar reflect = list$1.reflectFactory(context__namespace);\nvar createReflect = list$1.reflectCreateFactory(context__namespace);\nvar variant = list$1.variantFactory(context__namespace);\nvar list = list$1.listFactory(context__namespace);\n\nexports.createReflect = createReflect;\nexports.list = list;\nexports.reflect = reflect;\nexports.variant = variant;\n","'use strict';\n\nvar react = require('react');\nvar effector = require('effector');\n\nfunction reflectCreateFactory(context) {\n  var reflect = reflectFactory(context);\n  return function createReflect(view) {\n    return function (bind, params) {\n      return reflect(Object.assign({\n        view: view,\n        bind: bind\n      }, params));\n    };\n  };\n}\nfunction reflectFactory(context) {\n  return function reflect(config) {\n    var events = {};\n    var stores = {};\n    var data = {};\n\n    for (var key in config.bind) {\n      var value = config.bind[key];\n\n      if (effector.is.event(value, {\n        sid: \"gy0afy\"\n      }) || effector.is.effect(value, {\n        sid: \"gy0bwh\"\n      })) {\n        events[key] = value;\n      } else if (effector.is.store(value, {\n        sid: \"id568x\"\n      })) {\n        stores[key] = value;\n      } else {\n        data[key] = value;\n      }\n    }\n\n    var $bind = isEmpty(stores) ? null : effector.combine({\n      É”: [stores],\n      config: {\n        name: \"$bind\",\n        sid: \"-rtakm6\"\n      }\n    });\n    return function (props) {\n      var _a, _b;\n\n      var storeProps = $bind ? context.useStore($bind) : {};\n      var eventsProps = context.useEvent(events);\n      var elementProps = Object.assign({}, storeProps, eventsProps, data, props);\n      var hookMounted = readHook((_a = config.hooks) === null || _a === void 0 ? void 0 : _a.mounted, context);\n      var hookUnmounted = readHook((_b = config.hooks) === null || _b === void 0 ? void 0 : _b.unmounted, context);\n      react.useEffect(function () {\n        if (hookMounted) hookMounted();\n        return function () {\n          if (hookUnmounted) hookUnmounted();\n        };\n      }, []);\n      return /*#__PURE__*/react.createElement(config.view, elementProps);\n    };\n  };\n}\n\nfunction readHook(hook, context) {\n  if (hook) {\n    if (effector.is.event(hook, {\n      sid: \"-93to65\"\n    }) || effector.is.effect(hook, {\n      sid: \"-93tmqh\"\n    })) {\n      return context.useEvent(hook);\n    }\n\n    return hook;\n  }\n}\n\nfunction isEmpty(map) {\n  return Object.keys(map).length === 0;\n}\n\nvar Default = function Default() {\n  return null;\n};\n\nfunction variantFactory(context) {\n  var reflect = reflectFactory(context);\n  return function variant(config) {\n    var _a;\n\n    function View(props) {\n      var _a, _b;\n\n      var nameOfCase = context.useStore(config.source);\n      var Component = (_b = (_a = config.cases[nameOfCase]) !== null && _a !== void 0 ? _a : config[\"default\"]) !== null && _b !== void 0 ? _b : Default;\n      return /*#__PURE__*/react.createElement(Component, props);\n    }\n\n    var bind = (_a = config.bind) !== null && _a !== void 0 ? _a : {};\n    return reflect({\n      bind: bind,\n      view: View,\n      hooks: config.hooks\n    });\n  };\n}\n\nfunction listFactory(context) {\n  var reflect = reflectFactory(context);\n  return function list(config) {\n    var ItemView = reflect({\n      view: config.view,\n      bind: config.bind,\n      hooks: config.hooks\n    });\n    return function () {\n      return context.useList(config.source, {\n        fn: function fn(value, index) {\n          var finalProps = react.useMemo(function () {\n            var props = {\n              // TODO: remove that in favor of `getKey` in useList config\n              // when next effector-react version is released\n              key: config.getKey ? config.getKey(value, index) : index\n            };\n\n            for (var prop in config.mapItem) {\n              if ({}.hasOwnProperty.call(config.mapItem, prop)) {\n                // for some reason TS can't properly infer `prop` type here\n                var fn = config.mapItem[prop];\n                var propValue = fn(value, index);\n                props[prop] = propValue;\n              }\n            }\n\n            return props;\n          }, [value, index]);\n          return /*#__PURE__*/react.createElement(ItemView, finalProps);\n        }\n      });\n    };\n  };\n}\n\nexports.listFactory = listFactory;\nexports.reflectCreateFactory = reflectCreateFactory;\nexports.reflectFactory = reflectFactory;\nexports.variantFactory = variantFactory;\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Factory for creating new instances\naxios.create = function create(instanceConfig) {\n  return createInstance(mergeConfig(axios.defaults, instanceConfig));\n};\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\nvar validator = require('../helpers/validator');\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof config === 'string') {\n    config = arguments[1] || {};\n    config.url = arguments[0];\n  } else {\n    config = config || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),\n      clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar defaults = require('./../defaults');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar pkg = require('./../../package.json');\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\nvar currentVerArr = pkg.version.split('.');\n\n/**\n * Compare package versions\n * @param {string} version\n * @param {string?} thanVersion\n * @returns {boolean}\n */\nfunction isOlderVersion(version, thanVersion) {\n  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;\n  var destVer = version.split('.');\n  for (var i = 0; i < 3; i++) {\n    if (pkgVersionArr[i] > destVer[i]) {\n      return true;\n    } else if (pkgVersionArr[i] < destVer[i]) {\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator\n * @param {string?} version\n * @param {string} message\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  var isDeprecated = version && isOlderVersion(version);\n\n  function formatMessage(opt, desc) {\n    return '[Axios v' + pkg.version + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed in ' + version));\n    }\n\n    if (isDeprecated && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  isOlderVersion: isOlderVersion,\n  assertOptions: assertOptions,\n  validators: validators\n};\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return (typeof payload === 'object') && (payload.isAxiosError === true);\n};\n"],"sourceRoot":""}